{"meta":{"title":"Zongsoft","subtitle":"Zongsoft Studio","description":"Zongsoft","author":"钟峰(Popeye Zhong)","url":"http://zongsoft.com"},"pages":[],"posts":[{"title":"实体类的动态生成（三）","slug":"entity-dynamic-generation-3","date":"2018-07-16T16:00:00.000Z","updated":"2018-07-19T11:20:18.758Z","comments":true,"path":"zh-cn/zongsoft/entity-dynamic-generation-3/","link":"","permalink":"http://zongsoft.com/zh-cn/zongsoft/entity-dynamic-generation-3/","excerpt":"","text":"前言在 .NET 中主要有两种动态生成并编译的方式，一种是通过 System.Linq.Expressions 命名空间中的 LambdaExpression 类的 CompileToMethod(...) 方法，但是这种方法只支持动态编译到静态方法，因为这个限制我们将只能全面采用 Emitting 生成编译方案，虽然 Emitting 方案强大但是实现起来麻烦不少，必须要手动处理底层 IL 的各种细节，脑补一些 C# 编译器的实现机理，同时还要了解一些基本的 IL(Intermediate Language) 和 CLR(JVM) 执行方面的知识。 基础知识因为要采用 Emitting 技术方案，必然需要了解 IL，如果你之前没有怎么接触过，也不用灰心，网上有大量关于 IL 的入门文章，“30分钟入门”还是没问题的哈，毕竟 IL 相对 8086/8088 汇编来说，真的平易近人太多了。首先你需要一个类似 ILSpy(http://ilspy.net) 这样的工具来查看生成的IL或反编译程序集，最近版本还会提供 IL 与对应 C# 的比照解释，用户体验真是体贴得不要不要的。 一、不同于 8086/8088 这样基于寄存器的指令集，IL 和 Java 字节码一样都是基于栈的指令集，它们最明显的区别就是指令的参数指定方式的差异。以“int x = 100+200”操作为例，IL 的指令序列大致是：1234ldc.i4 100ldc.i4 200addstlocl.0 前两行代码分别将100和200这两个32位整数加载到运算栈(Evaluation Stack)中； 第3行的 add 是加法运算指令，它会从运算栈弹出(Pop)两次以得到它需要的两个操作数(Operand)，计算完成后又会将自己的计算结果压入(Push)到计算栈中，这时栈顶的元素就是累加的结果（即整数300）； 第4行的 stloc.0 是设置本地变量的指令，它会从计算栈弹出(Pop)一个元素，然后将该元素保存到特定本地变量中（本示例是第一个本地变量）。注：本地变量必须由方法预先声明。 二、基本上汇编语言或类似 IL 这样的中间指令集都没有高级语言中天经地义的 if/else、switch/case、do/while、for/foreach 这样的基本语言结构，它们只有类似 goto/jump/br 这样的无条件跳转和 br.true/br.false/beq/blt/bgt/ceq/clt/cgt 等之类的条件跳转指令，高级语言中的很多基本语言结构都是由编译器或解释器转换成底层的跳转结构的，所以在 Emitting 中我们也需要脑补编译器中这样的翻译机制，将那些 if/else、while、for 之类的翻译成对应的跳转结构。 需要特别指出的是，因为 C/C++/C#/JAVA 之类的高级语言的逻辑运算中有“短路”的内置约定，所以在转换成跳转结构时，必须留意处理这个问题，否则会破坏语义并可能导致运行时错误。 三、因为 IL 支持类名、字段、属性、方法等元素名称中包含除字母、数字、下划线之外的其他字符，所有各高级语言编译器都会利用该特性，主要是为了避免与特定高级语言中用户代码发生命名冲突，我们亦会采用该策略。 有了上面的基础知识，自己稍微花点时间阅读一些 IL 代码，再来翻阅 Zongsoft.Data.Entity 类的源码就简单了。另外，在反编译阅读 IL 代码的时候，如果你反编译的是 Debug 版本，会发现生成的 IL 对本地变量的处理非常啰嗦，重复保存又紧接着加载本地变量的操作，这是因为编译器没有做优化导致，不用担心，换成用 Release 编译就好很多了，但是依然还是有一些手动优化的空间。 接口说明实体动态生成器类的源码位于 Zongsoft.CoreLibrary 项目中（https://github.com/Zongsoft/Zongsoft.CoreLibrary/blob/feature-data/src/Data/Entity.cs），这是一个静态类，其主要公共方法定义如下： 12345678910public static Entity&#123; public static T Build&lt;T&gt;(); public static T Build&lt;T&gt;(Action&lt;T&gt; map); public static IEnumerable&lt;T&gt; Build&lt;T&gt;(int count, Action&lt;T, int&gt; map = null); public static object Build(Type type); public static object Build(Type type, Action&lt;object&gt; map); public static IEnumerable Build(Type type, int count, Action&lt;object, int&gt; map = null);&#125; 公共的 Save() 方法是一个供调试之用的方法，它会将动态编译的程序集保存到文件中，以便使用 ILSpy 这样的工具反编译查看，待 feature-data 合并到 master 分支之后会被移除。 关于跑分在 https://github.com/Zongsoft/Zongsoft.CoreLibrary/blob/feature-data/samples/Zongsoft.Samples.Entities/Program.cs 类中的 PerformanceDynamic(int count) 是动态生成的跑分（性能测试）代码，需要注意的是，如果是首次动态创建某个实体接口，内部会先进行动态编译。 下面这两种方式跑分测试方式会有不同的性能表现，大家先琢磨下原因再接着往下阅读。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546private static void PerformanceDynamic(int count)&#123; // 获取构建委托，可能会触发内部的预先编译（即预热） var creator = Data.Entity.GetCreator(typeof(Models.IUserEntity)); // 创建跑分计时器 var stopwatch = new Stopwatch(); stopwatch.Start(); //开始计时 /* 第一种跑分 */ for(int i = 0; i &lt; count; i++) &#123; // 调用构建委托来创建实体类实例 var user = (Models.IUserEntity)creator(); user.UserId = (uint)i; user.Avatar = \":smile:\"; user.Name = \"Name: \" + i.ToString(); user.FullName = \"FullName\"; user.Namespace = \"Zongsoft\"; user.Status = (byte)(i % byte.MaxValue); user.StatusTimestamp = (i % 11 == 0) ? DateTime.Now : DateTime.MinValue; user.CreatedTime = DateTime.Now; &#125; stopwatch.Restart(); //重新计时 /* 第二种跑分 */ int index = 0; // 动态构建指定 count 个实体类实例（懒构建） var entities = Data.Entity.Build&lt;Models.IUserEntity&gt;(count); foreach(var user in entities) &#123; user.UserId = (uint)index; user.Avatar = \":smile:\"; user.Name = \"Name: \" + index.ToString(); user.FullName = \"FullName\"; user.Namespace = \"Zongsoft\"; user.Status = (byte)(index % byte.MaxValue); user.StatusTimestamp = (index++ % 11 == 0) ? DateTime.Now : DateTime.MinValue; user.CreatedTime = DateTime.Now; &#125; stopwatch.Stop(); //停止计时&#125; 在我的老台式机上跑一百万（即count=1,000,000）次，第二种跑分代码比第一种差不多要慢50~100毫秒左右，两者区别就在于 for 循环与 Enumerable/Enumerator 模式的区别，我曾尝试对 Build&lt;T&gt;(int count) 方法内部的 yield return （由C#编译器将该语句翻译成 Enumerable/Enumerator 模式）改为手动实现，优化的思路是：因为在这个场景中，我们已知 count 数量，基于这个必要条件可以剔除 Enumerator 循环中一些不必要的条件判断代码。但是手动写了 Enumerable/Enumerator 后发现，为了代码安全性还是无法省略一些必要的条件判断，因为不能确定用户是否会采用 entities.GetEnumerator() + while 的方式来调用，也就是说即使在确定 count 的条件下也占不到任何性能上的便宜，毕竟基本的代码安全性还是要优先保障的。 基于上述原因，为了跑分就只好将 GetCreator(Type type) 这个私有方法暴露成公共的，但是这并不是说动态生成的代码有性能问题，只是在应对一次性创建上百万个实体实例并遍历的特殊场景下，为了排除 Enumerable/Enumerator 模式对性能的一点点“干扰”（这是必须的）的非常之举，在实际业务中没有必要这么处理，特此说明。 使用说明将原有业务系统中各种实体类改为接口，这些接口可以继承自 Zongsoft.Data.IEntity 也可以不用，不管实体接口是否从 Zongsoft.Data.IEntity 接口继承，动态生成的实体类都会实现该接口，因此依然可以将动态创建的实体实例强制转换为该接口。 注意：实体接口中不能含有事件、方法定义，即只能包含属性定义。 变更通知如果实体需要支持属性变更通知，则实体接口必须增加对 System.ComponentModel.INotifyPropertyChanged 接口的继承，但这样的支持需要付出一点点性能成本，以下是动态生成后的部分C#代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243public interface IPerson&#123; string Name &#123; get; set; &#125;&#125;// 不支持的属性变更通知版本public class Person : IPerson, IEntity&#123; public string Name &#123; get =&gt; _name; set =&gt; &#123; _name = value; _MASK_ |= 1; &#125; &#125;&#125;/* 增加对属性变更通知的特性 */public interface IPerson : INotifyPropertyChanged&#123; string Name &#123; get; set; &#125;&#125;// 支持属性变更通知版本public class Person : IPerson, IEntity, INotifyPropertyChanged&#123; // 事件声明 public event PropertyChangedEventHandler PropertyChanged; public string Name &#123; get =&gt; _name; set =&gt; &#123; if(_name == value) // 新旧值比对判断 return; _name = value; _MASK_ |= 1; this.PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(\"Name\")); &#125; &#125;&#125; 所谓一点点性能成本有两点：①需要对新旧值进行比对，比对方法的实现性能对此处有至关影响；②对 PropertyChanged 事件的有效性判断并调用事件委托。当然，如果这是必须的 feature 需求，那就无所谓成本了。 提示：关于新旧值比对的说明，如果属性类型是基元类型，动态生成器会生成 bne/be 这样的特定 IL 指令；否则如果该类型重写了 == 操作符则会使用该操作符的实现；否则会调用 Object.Equals(…) 静态方法来比对。 扩展属性在某些场景，需要手动处理属性的 getter 或 setter 的业务逻辑，那该如何在动态生成中植入这些逻辑代码呢？在 Zongsoft.Data.Entity 类中有个 PropertyAttribute 自定义特性类，可以利用它来声明扩展属性的实现。譬如下面的示例： 123456789101112131415161718192021222324252627282930313233343536373839404142public static UserExtension&#123; public static string GetAvatarUrl(IUser user) &#123; if(string.IsNullOrEmpty(user.Avatar)) return null; return \"URL:\" + user.Avatar; &#125;&#125;public interface IUser&#123; string Avatar &#123; get; set; &#125; [Entity.Property(Entity.PropertyImplementationMode.Extension, typeof(UserExtension))] string AvatarUrl &#123; get; &#125;&#125;/* 以下的 User 实体类为动态生成器生成的部分示意代码。*/public class User : IUser, IEntity&#123; private string _avatar; public string Avatar &#123; get =&gt; _avatar; set &#123; _avatar = value; _MASK_ |= xxx; &#125; &#125; public string AvatarUrl &#123; get &#123; return UserExtension.GetAvatarUrl(this); &#125; &#125;&#125; 上面的代码比较好理解，就不多说，如果 IUser 接口中的 AvatarUrl 属性是可读写属性或者有 System.ComponentModel.DefaultValueAttribute 自定义特性修饰，那么该属性就会有对应的字段，对应的属性扩展方法也可以获取该字段值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static class UserExtension&#123; public static string GetAvatarUrl(IUser user, string value) &#123; if(string.IsNullOrEmpty(value)) return $\"http://...&#123;user.Avatar&#125;...\"; return value; &#125;&#125;public interface IUser&#123; string Avatar &#123; get; set; &#125; [Entity.Property(Entity.PropertyImplementationMode.Extension, typeof(UserExtension))] string AvatarUrl &#123; get; set; &#125;&#125;/* 以下的 User 实体类为动态生成器生成的部分示意代码。*/public class User : IUser, IEntity&#123; private string _avatar; private string _avatarUrl; public string Avatar &#123; get =&gt; _avatar; set &#123; _avatar = value; _MASK_ |= xxx; &#125; &#125; // 只有读取获取扩展方法 public string AvatarUrl &#123; get =&gt; Extension.GetAvatarUrl(this, _avatarUrl); set &#123; _avatarUrl = value; _MASK_ |= xxx; &#125; &#125;&#125; 当然扩展属性方法支持读写两种，下面是同时实现了两个版本的扩展方法的样子： 123456789101112131415161718192021222324252627282930public static class UserExtension&#123; public static string GetAvatarUrl(IUser user, string value) &#123; throw new NotImplementedException(); &#125; public static bool SetAvatarUrl(IUser user, string value) &#123; throw new NotImplementedException(); &#125;&#125;/* 以下的 User 实体类为动态生成器生成的部分示意代码。*/public class User : IUser, IEntity&#123; public string AvatarUrl &#123; get =&gt; UserExtension.GetAvatarUrl(this, _avatarUrl); set &#123; if(UserExtension.SetAvatarUrl(this, _avatarUrl)) &#123; _avatarUrl = value; _MASK_ |= xxx; &#125; &#125; &#125;&#125; 扩展属性方法的定义约定： 必须是一个公共的静态方法； 读取方法名以 Get 打头，后面接扩展属性名并区分大小写； 读取方法的第一个参数必须是要扩展实体接口类型，第二个参数可选，如果有的话必须是扩展属性的类型；返回类型必须是扩展属性的类型； 设置方法名以 Set 打头，后面接扩展属性名并区分大小写； 设置方法的第一个参数必须是要扩展实体接口类型，第二参数是扩展属性的类型，表示设置的新值；返回类型必须是布尔类型，返回真(True)表示设置成功否则返回失败(False)，只有返回真对应的成员字段才会被设置更新。 单例模式某些场景中，属性需要采用单例模式来实现，譬如一些集合类型的属性。 12345678910111213141516171819202122232425262728293031323334public interface IDepartment&#123; [Entity.Property(Entity.PropertyImplementationMode.Singleton)] ICollection&lt;IUser&gt; Users &#123; get; &#125;&#125;/* 以下的 Department 实体类为动态生成器生成的部分示意代码。*/public class Department : IDepartment, IEntity&#123; private readonly object _users_LOCK; private ICollection&lt;IUser&gt; _users; public Department() &#123; _users_LOCK = new object(); &#125; public ICollection&lt;IUser&gt; Users &#123; get &#123; if(_users == null) &#123; lock(_users_LOCK) &#123; if(_users == null) &#123; _users = new List&lt;IUser&gt;(); &#125; &#125; &#125; return _users; &#125; &#125;&#125; 实现采用的是双检锁模式，必须注意到，每个单例属性都会额外占用一个用于双检锁的 object 类型变量。如果属性类型是集合接口，那么动态生成器会选择一个合适的实现该接口的集合类；当然，你也可以自定义一个工厂方法来创建对应的实例，在实体属性中通过 PropertyAttribute 自定特性中声明工厂方法所在的类型即可。 注意：工厂方法必须是一个公共的静态方法，有一个可选的参数，参数类型为实体接口类型。 123456789101112131415161718192021222324252627282930313233343536373839404142public static class DepartmentExtension&#123; public static ICollection&lt;IUser&gt; GetUsers(IDepartment department) &#123; return new MyUserCollection(department); &#125;&#125;public interface IDepartment&#123; [Entity.Property(Entity.PropertyImplementationMode.Singleton, typeof(DepartmentExtension))] ICollection&lt;IUser&gt; Users &#123; get; &#125;&#125;/* 以下的 Department 实体类为动态生成器生成的部分示意代码。*/public class Department : IDepartment, IEntity&#123; private readonly object _users_LOCK; private ICollection&lt;IUser&gt; _users; public Department() &#123; _users_LOCK = new object(); &#125; public ICollection&lt;IUser&gt; Users &#123; get &#123; if(_users == null) &#123; lock(_users_LOCK) &#123; if(_users == null) &#123; _users = DepartmentExtension.GetUsers(this); &#125; &#125; &#125; return _users; &#125; &#125;&#125; 默认值和自定义初始化有时我们需要只读属性，但又不需要单例模式这种相对较重的实现机制，可以采用 DefaultValueAttribute 这个自定义特性来处理这种情况。 提示：实体接口或属性声明的所有自定义特性都会被生成器添加到实体类的对应元素中，后面的演示代码可能会省略这些生成的自定义特性，特此说明。 123456789101112131415161718192021222324252627282930313233343536373839public interface IDepartment&#123; [DefaultValue(\"Popeye\")] string Name &#123; get; set; &#125; [DefaultValue] ICollection&lt;IUser&gt; Users &#123; get; &#125;&#125;/* 以下的 Department 实体类为动态生成器生成的部分示意代码。*/public class Department : IDepartment, IEntity&#123; private string _name; private ICollection&lt;IUser&gt; _users; public Department() &#123; _name = \"Popeye\"; _users = new List&lt;IUser&gt;(); &#125; [DefaultValue(\"Popeye\")] public string Name &#123; get =&gt; _name; set &#123; _name = value; _MASK_ |= xxx; &#125; &#125; [DefaultValue()] public ICollection&lt;IUser&gt; Users &#123; get =&gt; _users; &#125;&#125; 除了支持固定(Mutable)默认值，还支持动态(Immutable)的，所谓动态值是指它的值不在 DefaultValueAttribute 中被固化，即指定 DefaultValueAttribute 的值为一个静态类的类型，该静态类中必须有一个名为 Get 打头并以属性名结尾的方法，该方法可以没有参数，也可以有一个实体接口类型的参数，如下所示。 12345678910111213141516171819202122232425262728293031public static DepartmentExtension&#123; public static DateTime GetCreationDate() &#123; return DateTime.Now; &#125;&#125;public interface IDepartment&#123; [DefaultValue(typeof(DepartmentExtension))] DateTime CreationDate &#123; get; &#125;&#125;/* 以下的 Department 实体类为动态生成器生成的部分示意代码。*/public class Department : IDepartment, IEntity&#123; private DateTime _creationDate; public Department() &#123; _creationDate = DepartmentExtension.GetCreationDate(); &#125; public DateTime CreationDate &#123; get =&gt; _creationDate; &#125;&#125; 如果 DefaultValueAttribute 默认值自定义特性中指定的是一个类型(即 System.Type)，并且该类型不是一个静态类的类型，并且属性类型也不是 System.Type 的话，那则表示该类型为属性的实际类型，这对于某些属性被声明为接口或基类的情况下尤为有用，如下所示。 123456789101112131415161718192021222324252627282930313233public interface IDepartment&#123; [DefaultValue(typeof(MyManager))] IUser Manager &#123; get; set; &#125; [DefaultValue(typeof(MyUserCollection))] ICollection&lt;IUser&gt; Users &#123; get; &#125;&#125;/* 以下的 Department 实体类为动态生成器生成的部分示意代码。*/public class Department : IDepartment, IEntity&#123; private IUser _manager; private ICollection&lt;IUser&gt; _users; public Department() &#123; _managert = new MyManager(); _users = new MyUserCollection(); &#125; public IUser Manager &#123; get =&gt; _manager; &#125; public ICollection&lt;IUser&gt; Users &#123; get =&gt; _users; &#125;&#125; 其他说明默认生成的实体属性为公共属性（即非显式实现方式），当出现实体接口在继承中发生了属性重名，或因为某些特殊需求导致必须对某个实体属性以显式方式实现，则可通过 Entity.PropertyAttribute 自定特性中的 IsExplicitImplementation=true 来开启显式实现机制。 在实体接口中声明的各种自定义特性(Attribute)，都会被动态生成器原样添加到生成的实体类中。因此之前范例中，凡是接口以及接口的属性声明的各种自定义特性（包括：DefaultValueAttribute 、 Entity.PropertyAttribute ）都会被添加到动态生成的实体类的相应元素中，这对于某些应用是一个必须被支持的特性。 性能测试在《实体类的动态生成（二）》中，我们已经验证过设计方案的执行性能了，但结合上面介绍的功能特性细节，还需再提醒的是：因为开启 DefaultValueAttribute 、扩展属性方法、单例属性、属性变更通知都会导致生成的代码与最基本字段访问方式有所功能增强，对应要跑的代码量增多，因此对跑分是有影响，但这种影响是确定可知的，它们是 feature 所需并非实现方案、算法缺陷所致，敬请知晓。 譬如图二就是增加了属性变更通知（即实体接口继承了 INotifyPropertyChanged ）导致的性能影响（Dynamic Entity 所在行）。 写在最后的话该实体类动态生成器简单易用、运行性能和内存利用率都非常不错（包括提供 IEntiy 接口的超赞功能），将会成为今后我们所有业务系统的基础结构之一，所以后续的文章中（如果还有的话）应该会经常看到它的应用。 算下来花了整整三天时间（白天晚上都在写）才完成《实体类的动态生成》系列文章，真心觉得写文章比写代码还累，而且这还是省略了应该配有的一些流程图、架构图的情况下。计划接下来我会为 Zongsoft(https://github.com/Zongsoft) 系列开源项目撰写该有的所有文档，照这次这个写法，心底不由升起一丝莫名恐惧和淡淡忧伤来。 如果你觉得这次的文章对你有所帮助，又或者你觉得我们的开源项目做的还不错，请务必为我们点赞并关注我们的公众号，这或许是我坚持写下去的最大动力来源了。 最后，因为写这个东西耽搁了不少造 Zongsoft.Data 这个轮子的时间，所以接下来得全力去造轮子了。打算每周确保至少一篇干货满满的技术文章在公众号首发，希望不会让自己失望吧。 关于 Zongsoft.Data 它一定会是一款性能满血、易用且足够灵活的数据引擎，首发即会支持四大关系型数据库，后续会加入对 Elasticsearch 的支持，总之，它应该是不同市面上任何一款 ORM 数据引擎的开源产品。我会陆续与大家分享有关它的一些设计思考以及实现中遇到的问题，当然，也可以在 github 上围观我的进展。","categories":[{"name":"zongsoft","slug":"zongsoft","permalink":"http://zongsoft.com/categories/zongsoft/"}],"tags":[{"name":"实体","slug":"实体","permalink":"http://zongsoft.com/tags/实体/"},{"name":"动态编译","slug":"动态编译","permalink":"http://zongsoft.com/tags/动态编译/"},{"name":"动态生成","slug":"动态生成","permalink":"http://zongsoft.com/tags/动态生成/"},{"name":"entity","slug":"entity","permalink":"http://zongsoft.com/tags/entity/"},{"name":"emit","slug":"emit","permalink":"http://zongsoft.com/tags/emit/"},{"name":"dynamic","slug":"dynamic","permalink":"http://zongsoft.com/tags/dynamic/"},{"name":"generate","slug":"generate","permalink":"http://zongsoft.com/tags/generate/"},{"name":"compile","slug":"compile","permalink":"http://zongsoft.com/tags/compile/"}]},{"title":"实体类的动态生成（二）","slug":"entity-dynamic-generation-2","date":"2018-07-15T16:00:00.000Z","updated":"2018-07-19T11:20:13.438Z","comments":true,"path":"zh-cn/zongsoft/entity-dynamic-generation-2/","link":"","permalink":"http://zongsoft.com/zh-cn/zongsoft/entity-dynamic-generation-2/","excerpt":"","text":"前言由于采用字典的方式来保存属性变更值的底层设计思想，导致了性能问题，虽然.NET的字典实现已经很高效了，但相对于直接读写字段的方式而言依然有巨大的性能差距，同时也会导致对属性的读写过程中产生不必要的装箱和拆箱。那么这次我们就来彻底解决这个问题，同时还要解决“哪些属性发生过变更”“获取变更的属性集”这些功能特性，所以我们先把接口定义出来，以便后续问题讲解。 1234567891011121314151617181920212223242526272829303132333435363738/* 源码位于 Zongsoft.CoreLibary 项目的 Zongsoft.Data 命名空间中 *//// &lt;summary&gt; 表示数据实体的接口。&lt;/summary&gt;public interface IEntity&#123; /// &lt;summary&gt; /// 判断指定的属性或任意属性是否被变更过。 /// &lt;/summary&gt; /// &lt;param name=\"names\"&gt;指定要判断的属性名数组，如果为空(null)或空数组则表示判断任意属性。&lt;/param&gt; /// &lt;returns&gt; /// &lt;para&gt;如果指定的&lt;paramref name=\"names\"/&gt;参数有值，当只有参数中指定的属性发生过更改则返回真(True)，否则返回假(False)；&lt;/para&gt; /// &lt;para&gt;如果指定的&lt;paramref name=\"names\"/&gt;参数为空(null)或空数组，当实体中任意属性发生过更改则返回真(True)，否则返回假(False)。&lt;/para&gt; /// &lt;/returns&gt; bool HasChanges(params string[] names); /// &lt;summary&gt; /// 获取实体中发生过变更的属性集。 /// &lt;/summary&gt; /// &lt;returns&gt;如果实体没有属性发生过变更，则返回空(null)，否则返回被变更过的属性键值对。&lt;/returns&gt; IDictionary&lt;string, object&gt; GetChanges(); /// &lt;summary&gt; /// 尝试获取指定名称的属性变更后的值。 /// &lt;/summary&gt; /// &lt;param name=\"name\"&gt;指定要获取的属性名。&lt;/param&gt; /// &lt;param name=\"value\"&gt;输出参数，指定属性名对应的变更后的值。&lt;/param&gt; /// &lt;returns&gt;如果指定名称的属性是存在的并且发生过变更，则返回真(True)，否则返回假(False)。&lt;/returns&gt; /// &lt;remarks&gt;注意：即使指定名称的属性是存在的，但只要其值未被更改过，也会返回假(False)。&lt;/remarks&gt; bool TryGetValue(string name, out object value); /// &lt;summary&gt; /// 尝试设置指定名称的属性值。 /// &lt;/summary&gt; /// &lt;param name=\"name\"&gt;指定要设置的属性名。&lt;/param&gt; /// &lt;param name=\"value\"&gt;指定要设置的属性值。&lt;/param&gt; /// &lt;returns&gt;如果指定名称的属性是存在的并且可写入，则返回真(True)，否则返回假(False)。&lt;/returns&gt; bool TrySetValue(string name, object value);&#125; 设计思想根本要点是取消用字典来保存属性值回归到字段方式，只有这样才能确保性能，关键问题是如何在写入字段值的时候，标记对应的属性发生过变更的呢？应用布隆过滤器(Bloom Filter)算法的思路来处理这个应用场景是一个完美的解决方案，因为布隆过滤器的空间效率和查询效率极高，而它的缺点在此恰好可以针对性的优化掉。 将每个属性映射到一个整型数（byte/ushort/uint/ulong）的某个比特位(bit)，如果发生过变更则将该位置一，只要确保属性与二进制位顺序是确定的即可，算法复杂度是O(1)常量，并且比特位操作的效率也是极高的。 实现示范有了算法，我们写一个简单范例来感受下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127public class Person : IEntity&#123; #region 静态字段 private static readonly string[] __NAMES__ = new string[] &#123; \"Name\", \"Gender\", \"Birthdate\" &#125;; private static readonly Dictionary&lt;string, PropertyToken&lt;Person&gt;&gt; __TOKENS__ = new Dictionary&lt;string, PropertyToken&lt;Person&gt;&gt;() &#123; &#123; \"Name\", new PropertyToken&lt;Person&gt;(0, target =&gt; target._name, (target, value) =&gt; target.Name = (string) value) &#125;, &#123; \"Gender\", new PropertyToken&lt;Person&gt;(1, target =&gt; target._gender, (target, value) =&gt; target.Gender = (Gender?) value) &#125;, &#123; \"Birthdate\", new PropertyToken&lt;Person&gt;(2, target =&gt; target._birthdate, (target, value) =&gt; target.Birthdate = (DateTime) value) &#125;, &#125;; #endregion #region 标记变量 private byte _MASK_; #endregion #region 成员字段 private string _name; private bool? _gender; private DateTime _birthdate; #endregion #region 公共属性 public string Name &#123; get =&gt; _name; set &#123; _name = value; _MASK_ |= 1; &#125; &#125; public bool? Gender &#123; get =&gt; _gender; set &#123; _gender = value; _MASK_ |= 2; &#125; &#125; public DateTime Birthdate &#123; get =&gt; _birthdate; set &#123; _birthdate = value; _MASK_ |= 4; &#125; &#125; #endregion #region 接口实现 public bool HasChanges(string[] names) &#123; PropertyToken&lt;Person&gt; property; if(names == null || names.Length == 0) return _MASK_ != 0; for(var i = 0; i &lt; names.Length; i++) &#123; if(__TOKENS__.TryGetValue(names[i], out property) &amp;&amp; (_MASK_ &gt;&gt; property.Ordinal &amp; 1) == 1) return true; &#125; return false; &#125; public IDictionary&lt;string, object&gt; GetChanges() &#123; if(_MASK_ == 0) return null; var dictionary = new Dictionary&lt;string, object&gt;(__NAMES__.Length); for(int i = 0; i &lt; __NAMES__.Length; i++) &#123; if((_MASK_ &gt;&gt; i &amp; 1) == 1) dictionary[__NAMES__[i]] = __TOKENS__[__NAMES__[i]].Getter(this); &#125; return dictionary; &#125; public bool TryGetValue(string name, out object value) &#123; value = null; if(__TOKENS__.TryGetValue(name, out var property) &amp;&amp; (_MASK_ &gt;&gt; property.Ordinal &amp; 1) == 1) &#123; value = property.Getter(this); return true; &#125; return false; &#125; public bool TrySetValue(string name, object value) &#123; if(__TOKENS__.TryGetValue(name, out var property)) &#123; property.Setter(this, value); return true; &#125; return false; &#125; #endregion&#125;// 辅助结构public struct PropertyToken&lt;T&gt;&#123; public PropertyToken(int ordinal, Func&lt;T, object&gt; getter, Action&lt;T, object&gt; setter) &#123; this.Ordinal = ordinal; this.Getter = getter; this.Setter = setter; &#125; public readonly int Ordinal; public readonly Func&lt;T, object&gt; Getter; public readonly Action&lt;T, object&gt; Setter;&#125; 上面实现代码，主要有以下几个要点： 属性设置器中除了对字段赋值外，多了一个位或赋值操作（这是一句非常低成本的代码）； 需要一个额外的整型数的实例字段 _MASK_ ，来标记对应更改属性序号； 分别增加 __NAMES__ 和 __TOKENS__ 两个静态只读变量，来保存实体类的元数据，以便更高效的实现 IEntity 接口方法。 根据代码可分析出其理论执行性能与原生实现基本一致，内存消耗只多了一个字节（如果可写属性数量小于9），由于 __NAMES__ 和 __TOKENS__ 是静态变量，因此不占用实例空间，理论上该方案的整体效率非常高。 性能对比上面我们从代码角度简单分析了下整个方案的性能和消耗，那么实际情况到底怎样呢？跑个分呗（性能对比测试代码地址：https://github.com/Zongsoft/Zongsoft.CoreLibrary/tree/feature-data/samples/Zongsoft.Samples.Entities），具体代码就不在这里占用版面了，下面给出某次在我的老旧台式机（CPU:Intel i5-3470@3.2GHz | RAM:8GB | Win10 | .NET 4.6）上生成100万个实例的截图： “Native Object: 295”表示原生实现版（即简单的读写字段）的运行时长（单位：毫秒，下同）； “Data Entity: 295”为本案的运行时长，通常本方案比原生方案要慢10毫秒左右，偶尔能跑平（属于运行环境抖动，可忽略）； “Data Entity(TrySet): 835”为本方案中 TrySet(...) 方法的运行时长，由于 TrySet(...) 方法内部需要进行字典查询所以有性能损耗亦属正常，在百万量级跑到这个时长说明性能也是很不错的，如果切换到 .NET Core 2.1 的话，得益于基础类库的性能改善，还能再享受一波性能红利。 综上所述，该方案付出极少的内存成本获得了与原生简单属性访问基本一致的性能，同时还提供了属性变更跟踪等新功能（即高效完成了 Zongsoft.Data.IEntity 接口中定义的那些重要功能特性），为后续业务开发提供了有力的基础支撑。 实现完善上面的实现范例代码并没有实现 INotifyPropertyChanged 接口，下面补充完善下实现该接口后的属性定义： 12345678910111213141516171819public class Person : IEntity, INotifyPropertyChanged&#123; // 事件声明 public event PropertyChangedEventHandler PropertyChanged; public string Name &#123; get =&gt; _name; set &#123; if(_name == value) return; _name = value; _MASK_ |= 1; this.PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(Name))); &#125; &#125;&#125; 如上，属性的设置器中的做了一个新旧值的比对判断和对 PropertyChanged 事件激发，其他代码没有变化。 另外，我们使用的是 byte 类型的 _MASK_ 的标记变量来保存属性的更改状态，如果当实体的属性数量超过 8 个，就需要根据具体数量换成相应的 UInt16,UInt32,UInt64 类型，但如果超过 64 就需要采用 byte[] 了，当然必须要变动下相关代码，假设以下实体类有 100 个属性（注意仅例举了第一个 Property1 和最后一个 Property100 属性）： 12345678910111213141516171819202122232425262728293031public class Person : IEntity&#123; #region 标记变量 private readonly byte[] _MASK_; #endregion public Person() &#123; _MASK_ = new byte[13]; // 13 = Math.Ceiling(100 / 8) &#125; public object Property1 &#123; get =&gt; _property1; set &#123; _property1 = value; _MASKS_[0] |= 1; // _MASK_[0 / 8] |= (byte)Math.Pow(2, 0 % 8); &#125; &#125; public object Property100 &#123; get =&gt; _property100; set &#123; _property100 = value; _MASKS_[12] |= 8; // _MASK_[99 / 8] |= (byte)Math.Pow(2, 99 % 8); &#125; &#125;&#125; 变化内容为先根据当前属性的顺序号来确定到对应的标记数组的下标，然后再确定对应的掩码值。当然，也别忘了调整 Zongsoft.Data.IEntity 接口中各方法的实现。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class Person : IEntity&#123; public bool HasChanges(params string[] names) &#123; PropertyToken&lt;UserEntity&gt; property; if(names == null || names.Length == 0) &#123; for(int i = 0; i &lt; _MASK_.Length; i++) &#123; if(_MASK_[i] != 0) return true; &#125; return false; &#125; for(var i = 0; i &lt; names.Length; i++) &#123; if(__TOKENS__.TryGetValue(names[i], out property) &amp;&amp; (_MASK_[property.Ordinal / 8] &gt;&gt; (property.Ordinal % 8) &amp; 1) == 1) return true; &#125; return false; &#125; public IDictionary&lt;string, object&gt; GetChanges() &#123; var dictionary = new Dictionary&lt;string, object&gt;(__NAMES__.Length); for(int i = 0; i &lt; __NAMES__.Length; i++) &#123; if((_MASK_[i / 8] &gt;&gt; (i % 8) &amp; 1) == 1) dictionary[__NAMES__[i]] = __TOKENS__[__NAMES__[i]].Getter(this); &#125; return dictionary.Count == 0 ? null : dictionary; &#125; public bool TryGet(string name, out object value) &#123; value = null; if(__TOKENS__.TryGetValue(name, out var property) &amp;&amp; (_MASK_[property.Ordinal / 8] &gt;&gt; (property.Ordinal % 8) &amp; 1) == 1) &#123; value = property.Getter(this); return true; &#125; return false; &#125; public bool TrySetValue(string name, object value) &#123; /* 相对之前版本没有变化 */ /* No changes relative to previous versions */ &#125;&#125; 代码变化部分比较简单，只有掩码处理部分需要调整。 新问题有了这些实现范式，定义个实体基类并在基类中完成主要功能即可推广应用了，但是，这里有个掩码类型和处理方式无法通用化实现的问题，如果要把这部分代码交由子类来实现的话，那么代码复用度会大打折扣甚至完全失去复用的意义。 为展示这个问题的艰难，在 https://github.com/Zongsoft/Zongsoft.CoreLibrary/blob/feature-data/tests/Entities.cs 源文件中，写了属性数量不等的几个实体类（Person、Customer、Employee、SpecialEmployee），采用继承方式进行复用性验证，可清晰看到实现的非常冗长繁琐，对实现者的细节把控要求很高、实现上非常容易出错，更致命的是复用度还极差。并且当实体类需要进行属性增减，是非常麻烦的，需要仔细调整原有代码结构中掩码的映射位置，这对于代码维护无意是场恶梦。 新办法解决办法其实很简单，正是本文的标题——“动态生成”，彻底解放实现者并确保实现的正确性。业务方不再定义具体的实体类，而是定义实体接口即可，实体类将由实体生成器来动态生成。我们依然“从场景出发”，先来看看业务层的使用。 123456789101112131415public interface IPerson : IEntity&#123; string Name &#123; get; set; &#125; bool? Gender &#123; get; set; &#125; DateTime Birthdate &#123; get; set; &#125;&#125;public interface IEmployee : IPerson&#123; byte Status &#123; get; set; &#125; decimal Salary &#123; get; set; &#125;&#125;var person = Entity.Build&lt;IPerson&gt;();var employee = Entity.Build&lt;IEmployee&gt;(); 总结至此，终于得到了一个兼顾性能与功能并易于使用且无需繁琐的手动实现的最终方案，虽然刚开始看起来是一个多么平常又简单的任务。那么接下来我们该怎么实现这个动态生成器呢？最终它能性能无损的被实现出来吗？请关注我们的公众号（Zongsoft）留言讨论。 敬请期待更精彩的下篇，关注我们的公众号可以第一时间看到哦！","categories":[{"name":"zongsoft","slug":"zongsoft","permalink":"http://zongsoft.com/categories/zongsoft/"}],"tags":[{"name":"实体","slug":"实体","permalink":"http://zongsoft.com/tags/实体/"},{"name":"动态编译","slug":"动态编译","permalink":"http://zongsoft.com/tags/动态编译/"},{"name":"动态生成","slug":"动态生成","permalink":"http://zongsoft.com/tags/动态生成/"},{"name":"entity","slug":"entity","permalink":"http://zongsoft.com/tags/entity/"},{"name":"emit","slug":"emit","permalink":"http://zongsoft.com/tags/emit/"},{"name":"dynamic","slug":"dynamic","permalink":"http://zongsoft.com/tags/dynamic/"},{"name":"generate","slug":"generate","permalink":"http://zongsoft.com/tags/generate/"},{"name":"compile","slug":"compile","permalink":"http://zongsoft.com/tags/compile/"}]},{"title":"实体类的动态生成（一）","slug":"entity-dynamic-generation-1","date":"2018-07-14T16:00:00.000Z","updated":"2018-07-19T11:18:19.400Z","comments":true,"path":"zh-cn/zongsoft/entity-dynamic-generation-1/","link":"","permalink":"http://zongsoft.com/zh-cn/zongsoft/entity-dynamic-generation-1/","excerpt":"","text":"前言在应用开发中，通常都会涉及各种 POJO/POCO 实体类（DO, DTO, BO, VO）的编写，有时这些实体类还需要实现 INotifyPropertyChanged 接口以支持属性变更通知，一般我们都会手写这些代码或者通过工具根据数据库表定义抑或别的什么模板、映射文件之类的来生成它们。但是，在业务实现中往往伴随着诸如“如何简单且高效的获取某个实体实例有哪些属性发生过变更？”、“变更后的值是什么？”、“指定的某个或某些属性是否发生过更改？”这样的问题，而大致的解决方法有： 由实体容器来跟踪实例的属性变更； 改造实体类（譬如继承特定实体基类，在基类中实现这些基础构造）。 方法(1)需要配合一整套架构设计来提供支撑，也不是专为解决上述实体类的问题而设，并且实现和使用也都不够简单高效，故此略过不表。接下来我将通过几篇文章来详细阐述这些问题的来由以及解决方案，并给出完整的代码实现以及性能比对测试。 关于源码下面将要介绍的所有代码均位于我们的开源系列项目（地址：https://github.com/Zongsoft），项目主要采用 LGPL 2.1授权协议，欢迎大家参与并使用（请遵照授权协议）。而本文相关的源码位于其中 Zongsoft.CoreLibrary 项目的 feature-data 分支（https://github.com/Zongsoft/Zongsoft.CoreLibrary/tree/feature-data）及其中的 /samples/Zongsoft.Samples.Entities 范例项目，由于目前我正在忙着造 Zongsoft.Data 数据引擎这个轮子，不排除后面介绍到的代码会有一些调整，待该项目完成后这些代码亦会合并到 master 分支中，敬请留意。 基础版本万里长城也是从第一块砖头开始磊起来的，就让我们来搬第一块砖吧： 123456789101112131415161718192021222324252627282930public class User&#123; private uint _userId; private string _name; // 传统写法 public uint UserId &#123; get &#123; return _userId; &#125; set &#123; _userId = value; &#125; &#125; // C# 7.0 语法 public string Name &#123; get =&gt; _name; set =&gt; _name = value; &#125; // 懒汉写法：仅限不需要操作成员字段的场景 public string Namespace &#123; get; set; &#125;&#125; 以上代码特地用了三种编码方式，它们被C#编译器生成的IL没有模式上的不同，故而性能没有任何区别，大家根据自己的口味采用某种即可，因为我们的源码由于历史原因可能会有一些混写，在此一并做个展示而已。 由于业务需要，我们希望实体类能支持属性变更通知，即让它支持 INotifyPropertyChanged 接口，这么简单的需求当然不在话下： 12345678910111213141516171819202122232425262728293031323334353637public class User : INotifyPropertyChanged&#123; public event PropertyChangedEventHandler PropertyChanged; private uint _userId; private string _name; public uint UserId &#123; get =&gt; _userId; set &#123; if(_userId == value) return; _userId = value; this.OnPropertyChanged(\"UserId\"); // 传统写法 &#125; &#125; public string Name &#123; get =&gt; _name; set &#123; if(_name == value) return; _name = value; this.OnPropertyChanged(nameof(Name)); // nameof 为 C# 7.0 新增操作符 &#125; &#125; protected virtual void OnPropertyChanged(string propertyName) &#123; // 注意 ?. 为 C# 7.0 新增操作符 this.PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName)); &#125;&#125; 一切看起来是那么完美，但是，当我们写了几个这样的实体类，尤其是有些实体类的属性还不少时，体验就有点糟糕了。自然我们会想到写个实体基类来实现属性变更通知的基础构造，当然，在某些特定场景也可以通过工具来生成类似上面这样的C#实体类文件，但工具生成的方式有一定局限性并且不易维护（譬如需要在生成的代码基础上进行特定改造），在此不再赘述。 实体基类在进行基础类库或API设计的时候，我有个建议：从应用场景开始。具体的作法是，先尝试编写使用这些API的应用代码，待各种应用场景的使用代码基本都完成后，API接口也就自然而然的确定了。譬如，在我们这个需求中我希望这么去使用实体基类： 1234567891011121314151617public class User : ModelBase&#123; private uint _userId; private string _name; public uint UserId &#123; get =&gt; _userId; set =&gt; this.SetPropertyValue(nameof(UserId), ref _userId, value); &#125; public string Name &#123; get =&gt; _name; set =&gt; this.SetPropertyValue(nameof(Name), ref _name, value); &#125;&#125; 有了这样的实体基类后，增强了功能后代码依然如第一块砖的“基础版本”一样简洁，真是高兴啊！但这就够了么，能不能把具体实体类里面的成员字段也省了，交给基类来处理呢？嗯，有点意思，试着写下应用场景代码： 12345678public class User : ModelBase&#123; public uint UserId &#123; get =&gt; (uint)this.GetPropertyValue(nameof(UserId)); set =&gt; this.SetPropertyValue(nameof(UserId), value); &#125;&#125; 看起来棒极了，代码变得更简洁了，真是天才啊！淡定，丧心病狂的 C# 设计者似乎看到了这种普遍的需求，于是在 C# 5 中增加了 System.Runtime.CompilerServices.CallerMemberNameAttribute 自定义标记，C# 编译器将自动把调用者名字生成出来传递给加注了该标记的参数，因此这样的代码还可以继续简化： 12345678public class User : ModelBase&#123; public uint UserId &#123; get =&gt; (uint)this.GetPropertyValue(); set =&gt; this.SetPropertyValue(value); &#125;&#125; 但是，属性的 getter 里面的那个类型强制转换，怎么看都像是一朵“乌云”啊，能不能把它也去掉呢？嗯，利用C#的泛型类型推断可以完美解决它，继续强势进化： 12345678public class User : ModelBase&#123; public uint UserId &#123; get =&gt; this.GetPropertyValue(() =&gt; this.UserId); set =&gt; this.SetPropertyValue(() =&gt; this.UserId, value); &#125;&#125; 哇喔，有点小崇拜自己了，这代码漂亮的一批！至此，实体基类的API接口基本确定，已经迫不及待想要去实现它了。 提示：由于采用 CallerMemberNameAttribute 自定义标记的参数会导致 C# 编译器要求该参数必需有默认值，因此有些 SetPropertyValue(...) 方法重载版本中 propertyName 参数需要位于参数集的最后，为了与上面的范例代码对应就省略了这些参数的标记，并保持与原有范例相同的签名设计。 1234567891011121314using System;using System.Linq.Expressions;public class ModelBase : INotifyPropertyChanged&#123; public event PropertyChangedEventHandler PropertyChanged; protected object GetPropertyValue([CallerMemberName]string propertyName = null); protected T GetPropertyValue&lt;T&gt;(Expression&lt;Func&lt;T&gt;&gt; property); protected void SetPropertyValue&lt;T&gt;(string propertyName, ref T field, T value); protected void SetPropertyValue&lt;T&gt;(string propertyName, T value); protected void SetPropertyValue&lt;T&gt;(Expression&lt;Func&lt;T&gt;&gt; property, T value);&#125; 实体基类的实现主要思路就是采用字典来记录各属性的变更值，有了这个基础，要继续增加诸如“获取哪些属性发生过变更”之类的需求自然就很容易了： 1234567public class ModelBase : INotifyPropertyChanged&#123; // other members public bool HasChanges(params string[] propertyNames); public IDictionary&lt;string, object&gt; GetChangedPropertys();&#125; 具体的代码就不在这里贴出了，有兴趣的可以参考：https://github.com/Zongsoft/Zongsoft.CoreLibrary/blob/master/src/Common/ModelBase.cs，从功能角度上看，目前的设计还是不错的。但是，某些方法的设计有严重性能缺陷的，主要有以下几点： 每次读写属性都会解析 Lambda 表达式的操作会产生巨大的性能损耗； 采用字典来保存实体属性值的设计机制，会导致值类型的属性读写反复被装箱(Boxing)、拆箱(Unboxing)； 字典的读写效率也远低于直接操作成员字段的语言原语方式。 综上所述，虽然目前方案有性能缺陷，但应对一般场景其实是没有问题的，而且功能和易用性方面都是很好的；但是，性能对于后台程序猿而言犹如悬在头顶的达摩克利斯之剑，这正是这个系列文章要最终解决的问题。在此之前，如果大家有关于这个问题的性能优化方案，欢迎关注我们的公众号（Zongsoft）留言讨论。 敬请期待更精彩的下篇，关注我们的公众号可以第一时间看到哦！","categories":[{"name":"zongsoft","slug":"zongsoft","permalink":"http://zongsoft.com/categories/zongsoft/"}],"tags":[{"name":"实体","slug":"实体","permalink":"http://zongsoft.com/tags/实体/"},{"name":"动态编译","slug":"动态编译","permalink":"http://zongsoft.com/tags/动态编译/"},{"name":"动态生成","slug":"动态生成","permalink":"http://zongsoft.com/tags/动态生成/"},{"name":"entity","slug":"entity","permalink":"http://zongsoft.com/tags/entity/"},{"name":"emit","slug":"emit","permalink":"http://zongsoft.com/tags/emit/"},{"name":"dynamic","slug":"dynamic","permalink":"http://zongsoft.com/tags/dynamic/"},{"name":"generate","slug":"generate","permalink":"http://zongsoft.com/tags/generate/"},{"name":"compile","slug":"compile","permalink":"http://zongsoft.com/tags/compile/"}]},{"title":"搭建 github.io 博客站点","slug":"github-site","date":"2018-07-10T10:00:00.000Z","updated":"2018-07-19T10:28:17.565Z","comments":true,"path":"zh-cn/misc/github-site/","link":"","permalink":"http://zongsoft.com/zh-cn/misc/github-site/","excerpt":"","text":"前言很多人都有搭建博客或知识库站点的想法，可自己买云服务器太不划算，部署管理也是个问题；基于免费又热门的 GitHub Pages 来搭建博客站点倒是省钱省力省事的好办法，于是上网一搜，满屏都是关于使用 Jekyll 来搭建站点的文章，这个 Jekyll 是基于 Ruby 开发的，上手得先装一大坨东西、各种啰嗦各种坑，看的一点欲望都没有了。 神器出现平地一声雷，炸出了 Hexo (https://hexo.io/zh-cn) 这个神器。它只需要 NodeJS 即可，完全不依赖其他乱七八糟的玩意，安装部署超级简单，功能完善、漂亮主题也很多，妥妥的就是它了。 Hexo 官网：https://hexo.io/zh-cn/ 安装简单，并且官网上提供了很多主题可供选择。 我喜欢的一款主题 (Archer) http://firework.studio/archer-demo/https://github.com/fi3ework/hexo-theme-archer 建站步骤有关一般建站步骤，请参考本文后面的“参考文章”部分，在进行后续操作之前，请按照 Hexo 官网的安装指引，确保 NodeJS 和 Hexo 已经成功安装。 友情提示：在此之前请务必详读 Hexo 官网中的文档。 我们的站点源码：https://github.com/Zongsoft/zongsoft.github.io，没必要把 Hexo 运行环境和使用的主题文件都保存在站点仓库中，所以需要将这些不需要的目录和文件加入到 .gitignore 文件中；站点的 Hexo 基本配置(hexo.config.yml)和相应主题配置文件(hexo.config-theme.archer)需要保留，以便下次或别人构建时将其覆盖还原为默认配置。 站点构建在首次 clone 获取我们站点源码后，按顺序执行下列命令，注意：推荐在 Git Bash 中进行操作。 初始化 Hexo 站点目录： 1hexo init site &amp;&amp; cd site 安装相关插件： 1npm i hexo-generator-json-content --save &amp;&amp; npm i hexo-wordcount --save 获取 Archer 主题： 1git clone https://github.com/fi3ework/hexo-theme-archer.git themes/archer 覆盖 Hexo 默认配置文件： 1cp ../hexo.config.yml _config.yml 覆盖 Archer 主题默认配置文件： 1cp ../hexo.config-theme.archer.yml themes/archer/_config.yml 加入定制的页面布局： 1cp ../post-footer.ejs themes/archer/layout/_partial/post-footer.ejs 安装 Hexo 站点： 1npm install 文章写作上面的构建过程稍微需要花点时间，但只要构建一次之后就不用管它了。 通过 hexo new [layout] &lt;title&gt; 命令来创建一个文章，也可以手动把写好的文章拷贝到源目录(/docs/_posts/)中。 执行 hexo generate 命令生成静态页面(/blog)，生成之后，可以使用 hexo server 命令来查看实际效果。 最后，执行相关 Git 命令将这些改动提交到远程仓库中。 注意：创建了一篇新文章后，务必要设置好文章的元信息（即标题、创建时间、所属分类、Tags等），具体定义请参考 Hexo 官网的这篇文章：https://hexo.io/zh-cn/docs/front-matter.html 提示：如果生成有问题，可以执行 hexo clean 命令来清空输出目录，之后再把项目所需的资源文件手动拷贝到输出目录的相应子目录中。 其他备注 修改 post.ejs (site/themes/archer/layout/) 模板，增加对 post-footer.ejs 局部模板的引用： 123456&lt;main class=\"main post-page\"&gt; &lt;article class=\"article-entry\"&gt; &lt;%- page.content %&gt; &lt;/article&gt;&lt;%- partial('_partial/post-footer') %&gt; 修改 post.ejs 模板中的分页指示的标签： &lt;div class=&quot;nextSlogan&quot;&gt;Next Post&lt;/div&gt;&lt;a class=&quot;nextSlogan&quot; href=&quot;&lt;%- url_for(page.prev.path) %&gt;&quot;&gt;Next Post&lt;/a&gt;… …&lt;div class=&quot;prevSlogan&quot;&gt;Previous Post&lt;/div&gt;&lt;a class=&quot;prevSlogan&quot; href=&quot;&lt;%- url_for(page.next.path) %&gt;&quot;&gt;Previous Post&lt;/a&gt; 调整了 Archer 主题的 _post_page.scss (site/themes/archer/src/scss/_partial/) 中的部分样式： 12345678910111213141516171819// ========== paginator ========== //.post-paginator &#123; li &#123; max-width:18rem; &#125; .nextTitle, .prevTitle&#123; font-size:1.2rem; //remove this line &#125;&#125;// ========== content ========== //.abstract-content,.article-entry &#123; &gt; p &#123; text-indent:2em; &#125;&#125; 参考文章 《使用 Hexo &amp; GitPage 搭建博客》https://yuque.com/skyrin/coding/tm8yf5 《从多说到跟帖：推荐网易云跟帖》https://blog.vadxq.com/dstogentie/ 《集成gitment或者gitalk评论系统》http://www.huyanbing.me/2017/10/20/46383.html","categories":[{"name":"misc","slug":"misc","permalink":"http://zongsoft.com/categories/misc/"}],"tags":[{"name":"github.io","slug":"github-io","permalink":"http://zongsoft.com/tags/github-io/"},{"name":"github pages","slug":"github-pages","permalink":"http://zongsoft.com/tags/github-pages/"},{"name":"Hexo","slug":"Hexo","permalink":"http://zongsoft.com/tags/Hexo/"},{"name":"建站","slug":"建站","permalink":"http://zongsoft.com/tags/建站/"},{"name":"博客","slug":"博客","permalink":"http://zongsoft.com/tags/博客/"}]}]}