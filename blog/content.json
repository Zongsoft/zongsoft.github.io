{"meta":{"title":"Zongsoft","subtitle":"Zongsoft Studio","description":"Zongsoft","author":"钟峰(Popeye Zhong)","url":"http://zongsoft.com","root":"/blog/"},"pages":[],"posts":[{"title":"Zongsoft.Data 发布公告","slug":"announcing-data-engine","date":"2019-11-18T16:00:00.000Z","updated":"2019-11-18T19:56:46.597Z","comments":true,"path":"zh-cn/zongsoft/announcing-data-engine/","link":"","permalink":"http://zongsoft.com/zh-cn/zongsoft/announcing-data-engine/","excerpt":"","text":"Zongsoft.Data 发布公告很高兴我们的 ORM 数据访问框架(Zongsoft.Data)在历经两个 SaaS 产品的应用之后，今天正式宣布对外推广！这是一个类 GraphQL 风格的 ORM(Object/Relational Mapping) 数据访问框架。 又一个轮子？在很长时间里，.NET 阵营似乎一直缺乏一个被普遍使用的 ORM 数据访问框架，从最早的原生 ADO.NET 到舶来品 iBatis.NET 和 Hibernate.NET，后来又经历了 Linq for SQL 与 Entity Framework 的混战，可能是因为 Entity Framework 早期版本的模糊定位和反复变更的设计导致了它失之霸主之位，进而造就了一段百舸争流、群雄共逐的战国时代。在历经漫长而反复的期待、失望、纠结和痛苦之后，我终于决定动手造一个轮子。 设计理念在开始动手之前，先确定以下基本设计原则： 数据库优先(Database First) 严格的 POCO/POJO 支持 映射模型与代码完全隔离 禁止业务层出现 SQL 和类 SQL 代码 在一个业务系统中，数据结构及其关系毋庸置疑是最底层的基础性结构，数据库应由系统架构师或开发负责人进行仔细设计 _（No Schema/Weakly Schema 的思潮是涂抹了蜂蜜的毒药）_，数据访问映射以数据库表结构关系为基石，在此之上业务层亦以概念映射模型为准绳，层级之间相互隔离。 领域模型实体避免通过注解 (标签) 来进行元数据定义，应确保严格符合 POCO/POJO 范式。通过语义化的 Schema 来声明访问的数据结构关系，禁止应用层的 SQL 和 Linq 式的类 SQL 代码可降低业务层对数据层的依赖、提升代码可维护性外，还具备更加统一可控的便利性，并为数据访问引擎的实现提供了更大的优化空间和自由度。 范例说明下面通过三个的例子 （注：例子均基于 Zongsoft.Community 项目） 来佐证上面的部分设计理念，更多示例和阐述请参考 Zongsoft.Data 项目的 README.md 文档和 Zongsoft.Community 项目的代码。 提示： 下面的范例均基于 Zongsoft.Community 开源项目，该项目是一个完整的论坛社区的后台程序。你可能需要预先阅读一下该项目的《数据库表结构设计》文档，以便更好的理解范例代码的业务逻辑。 示例一导航查询及导航过滤 123456789101112131415var forums = this.DataAccess.Select&lt;Forum&gt;( Condition.Equal(\"SiteId\", this.User.SiteId) &amp; Condition.In(\"Visibility\", Visibility.Internal, Visibility.Public) | ( Condition.Equal(\"Visibility\", Visibility.Specified) &amp; Condition.Exists(\"Users\", Condition.Equal(\"UserId\", this.User.UserId) &amp; ( Condition.Equal(\"IsModerator\", true) | Condition.NotEqual(\"Permission\", Permission.None) ) ) ), \"*, MostRecentThread&#123;ThreadId,Title,Creator&#123;Name,Nickname,Avatar&#125;&#125;\"); 上述数据访问的查询方法大致生成如下SQL脚本： 1234567891011121314151617181920212223242526272829303132SELECT t.*, t1.ThreadId AS 'MostRecentThread.ThreadId', t1.Title AS 'MostRecentThread.Title', t1.CreatorId AS 'MostRecentThread.CreatorId', t2.UserId AS 'MostRecentThread.Creator.UserId', t2.Name AS 'MostRecentThread.Creator.Name', t2.Nickname AS 'MostRecentThread.Creator.Nickname', t2.Avatar AS 'MostRecentThread.Creator.Avatar'FROM Forum t LEFT JOIN Thread AS t1 ON t.MostRecentThreadId=t1.ThreadId LEFT JOIN UserProfile AS t2 ON t1.CreatorId=t2.UserIdWHERE t.SiteId = @p1 AND t.Visibility IN (@p2, @p3) OR ( t.Visibility = @p4 AND EXISTS ( SELECT u.SiteId, u.ForumId, u.UserId FROM ForumUser u WHERE u.SiteId = t.SiteId AND u.ForumId = t.ForumId AND u.UserId = @p5 AND ( u.IsModerator = @p6 OR u.Permission != @p7 ) ) ); 上述示例通过 Select 查询方法的 schema 参数 （即值为 *, MostRecentThread{ThreadId,Title,Creator{Name,Nickname,Avatar}} 的参数） 从数据结构关系的层次指定了查询数据的形状，因而不再需要 SQL 或类 SQL 语法中 JOIN 这样命令式的语法元素，它不光提供了更简洁且语义化的 API 访问方式，而且还给数据访问引擎底层提供了更大的优化空间和自由度。 如果将 Select 查询方法的 schema 参数值改为 *,Moderators{*},MostRecentThread{ThreadId,Title,Creator{Name,Nickname,Avatar}} 后，数据访问引擎会将查询内部分解为一对多的两条 SQL 语句进行迭代执行，而这些都不需要业务层进行分拆处理，因而提升了效率并降低了业务层的复杂度。 注： 将 Schema 模式表达式通过 Web API 提供给前端应用，将大大减少后端开发的工作量，提升前后端的工作效率。 示例二一对多的关联新增 123456789101112131415161718// 构建待新增的实体对象var forum = new&#123; SiteId = this.User.SiteId, GroupId = 100, Name = \"xxxx\", // 一对多的导航属性 Users = new ForumUser[] &#123; new ForumUser &#123; UserId = 1001, IsModerator = true &#125;, new ForumUser &#123; UserId = 1002, Permission = Permission.Read &#125;, new ForumUser &#123; UserId = 1003, Permission = Permission.Write &#125;, &#125;&#125;// 执行数据新增操作this.DataAccess.Insert&lt;Forum&gt;(forum, \"*, Users&#123;*&#125;\"); 上述数据访问的新增方法大致生成如下SQL脚本： 12345/* 主表插入语句，执行一次 */INSERT INTO Forum (SiteId,ForumId,GroupId,Name,...) VALUES (@p1,@p2,@p3,@p4,...);/* 子表插入语句，执行多次 */INSERT INTO ForumUser (SiteId,ForumId,UserId,Permission,IsModerator) VALUES (@p1,@p2,@p3,@p4,@p5); 上述示例通过 Insert 新增方法的 schema 参数（即值为 *,User{*} 的参数）指定了新增数据的形状，由数据访问引擎根据映射定义自动处理底层的 SQL 执行方式，确保业务层代码的简洁和更高的执行效率。 示例三一对一和一对多的关联更新，对于“一对多”的导航属性，还能确保该属性值 (集合类型) 以 UPSERT 模式写入。 12345678910111213141516171819202122public bool Approve(ulong threadId)&#123; //构建更新的条件 var criteria = Condition.Equal(nameof(Thread.ThreadId), threadId) &amp; Condition.Equal(nameof(Thread.Approved), false) &amp; Condition.Equal(nameof(Thread.SiteId), this.User.SiteId) &amp; Condition.Exists(\"Forum.Users\", Condition.Equal(nameof(Forum.ForumUser.UserId), this.User.UserId) &amp; Condition.Equal(nameof(Forum.ForumUser.IsModerator), true)); //执行数据更新操作 return this.DataAccess.Update&lt;Thread&gt;(new &#123; Approved = true, ApprovedTime = DateTime.Now, Post = new &#123; Approved = true, &#125; &#125;, criteria, \"*,Post&#123;Approved&#125;\") &gt; 0;&#125; 上述数据访问的更新方法大致生成如下SQL脚本： 12345678910111213141516171819202122232425262728293031323334353637/* 以下代码为支持 OUTPUT/RETURNING 子句的数据库（如：SQLServer,Oracle,PostgreSQL） *//* 根据更新的关联键创建临时表 */CREATE TABLE #TMP( PostId bigint NOT NULL);/* 更新主表，并将更新的关联键输出到内存临时表 */UPDATE T SET T.[Approved]=@p1, T.[ApprovedTime]=@p2OUTPUT DELETED.PostId INTO #TMPFROM [Community_Thread] AS T LEFT JOIN [Community_Forum] AS T1 ON /* Forum */ T1.[SiteId]=T.[SiteId] AND T1.[ForumId]=T.[ForumId]WHERE T.[ThreadId]=@p3 AND T.[Approved]=@p4 AND T.[SiteId]=@p5 AND EXISTS ( SELECT [SiteId],[ForumId] FROM [Community_ForumUser] WHERE [SiteId]=T1.[SiteId] AND [ForumId]=T1.[ForumId] AND [UserId]=@p6 AND [IsModerator]=@p7 );/* 更新关联表 */UPDATE T SET T.[Approved]=@p1FROM [Community_Post] AS TWHERE EXISTS ( SELECT [PostId] FROM #TMP WHERE [PostId]=T.[PostId]); 上述示例通过 Update 更新方法的 schema 参数（即值为 *,Post{Approved} 的参数）指定了更新数据的形状，数据访问引擎将根据数据库类型生成高效的 SQL 语句，对于业务层而言这一切都是无感的、透明的。 对于一对多的导航属性，数据访问引擎默认将以 UPSERT 模式处理子集的写入，关于 UPSERT 更多信息请参考 Zongsoft.Data 项目文档。 性能我们希望提供最佳的综合性价比，对于一个 ORM 数据访问引擎来说，性能的关注点主要 (不限) 有这些要素： 生成简洁高效的 SQL 脚本，并尽可能利用特定数据库的最新 SQL 语法； 数据查询结果的实体组装(Populate)过程必须高效； 避免反射，有效的语法树缓存。 实现层面我们采用 Emitting 动态编译技术对实体组装(Populate)、数据参数绑定等进行预热处理，可查阅 DataPopulator 等相关类的源码深入了解。 其他得益于 “以声明方式来表达数据结构关系” 的语义化设计理念，相对于命令式设计而言，它使得程序意图更加聚焦，天然地对底层数据的表达和优化更加宽容与自由。 更多详细内容 （譬如：读写分离、继承表、数据模式、映射文件、过滤器、验证器、类型转换、数据隔离） 请查阅相关文档。 支持赞助我们欢迎并期待任何形式的推广支持！ 如果你认同我们的设计理念请为这个项目点赞(Star)，如果你认为该项目很有用，并且希望支持它未来的发展，请给予必要的资金来支持它： 关注 Zongsoft 微信公众号，对我们的文章进行打赏； 加入 Zongsoft 知识星球圈，可以获得在线问答和技术支持； 如果您的企业需要现场技术支持与辅导，又或者需要开发新功能、即刻的错误修复等请发邮件给我。","categories":[{"name":"zongsoft","slug":"zongsoft","permalink":"http://zongsoft.com/categories/zongsoft/"}],"tags":[{"name":"ORM","slug":"ORM","permalink":"http://zongsoft.com/tags/ORM/"},{"name":"data access","slug":"data-access","permalink":"http://zongsoft.com/tags/data-access/"},{"name":"data engine","slug":"data-engine","permalink":"http://zongsoft.com/tags/data-engine/"},{"name":"数据访问","slug":"数据访问","permalink":"http://zongsoft.com/tags/%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/"},{"name":"数据引擎","slug":"数据引擎","permalink":"http://zongsoft.com/tags/%E6%95%B0%E6%8D%AE%E5%BC%95%E6%93%8E/"},{"name":"entity framework","slug":"entity-framework","permalink":"http://zongsoft.com/tags/entity-framework/"}]},{"title":"关于 IIS Express 常用设置","slug":"iis-express","date":"2019-05-01T11:00:00.000Z","updated":"2019-11-17T17:45:00.626Z","comments":true,"path":"zh-cn/misc/iis-express/","link":"","permalink":"http://zongsoft.com/zh-cn/misc/iis-express/","excerpt":"","text":"关于 IIS Express 常用设置 站点绑定IIS Express Web 服务器默认只绑定了 localhost 的主机名，这就意味着无法通过内网或其他自定义域名进行访问，可通过如下操作添加其他绑定。在Web宿主项目中的 .vs 目录中的 config 子目录中，有名为“applicationhost.config”配置文件，打开它后，找到如下节点： 1system.applicationHost/sites/site[name=xxxx]/bindings 在该绑定集中的添加一个首节点，假定绑定端口号为： 12345 1&lt;binding protocol=\"http\" bindingInformation=\"*:12345:*\" /&gt; 以管理员方式运行“命令提示符”，然后在终端执行器中执行下面命令： 1netsh http add urlacl url=http://*:12345:* user=everyone 注：如果指定端口被其他 IIS Express 服务占用，可使用如下命令解除相关绑定： 1netsh http delete urlacl url=http://*:12345/ 请求内容长度限制IIS Express Web 服务器默认限制了HTTP的请求内容大小，这会导致在上传较大文件时请求被拒绝，通过如下方式可重置默认限制值。在Web宿主项目中的 .vs 目录中的 config 子目录中，有名为“applicationhost.config”配置文件，打开它后，找到如下节点： 1system.webServer/security/requestFiltering 在该节点下添加如下子节点，假定重新设置请求内容长度限制为： 500MB 1&lt;requestLimits maxAllowedContentLength=\"524288000\" /&gt; 然后修改Web宿主项目的 Web.config 文件中的如下配置节： 123&lt;system.web&gt; &lt;httpRuntime maxRequestLength=\"524288000\" /&gt;&lt;/system.web&gt;","categories":[{"name":"misc","slug":"misc","permalink":"http://zongsoft.com/categories/misc/"}],"tags":[{"name":"Visual Studio","slug":"Visual-Studio","permalink":"http://zongsoft.com/tags/Visual-Studio/"},{"name":"IIS Express","slug":"IIS-Express","permalink":"http://zongsoft.com/tags/IIS-Express/"},{"name":"site binding","slug":"site-binding","permalink":"http://zongsoft.com/tags/site-binding/"},{"name":"request limit","slug":"request-limit","permalink":"http://zongsoft.com/tags/request-limit/"}]},{"title":"代码失控与状态机（下）","slug":"coding-outcontrol-statemachine-2","date":"2018-09-03T10:00:00.000Z","updated":"2019-11-17T17:45:00.624Z","comments":true,"path":"zh-cn/zongsoft/coding-outcontrol-statemachine-2/","link":"","permalink":"http://zongsoft.com/zh-cn/zongsoft/coding-outcontrol-statemachine-2/","excerpt":"","text":"序言在《代码失控与状态机（上）》的文末，我们留了一个解析「成员访问表达式」的“作业”，那么，通过本文我们一起来完成这个作业。 首先，为什么要苦哈哈的写一个这样看上去没什么用的解析器？因为在某些 IoC 或 AOP 容器中（不幸的是我需要实现一个这样的 IoC 容器），常需要动态求解成员访问表达式的值，而解析表达式就是第一步。其实这个“作业”正是编译器技术中词法解析的简化版，自己手动撸一遍，对理解《编译原理》的前端处理技巧是一个很好的入门练手。 其次，我现在正在造一个 ORM 数据引擎，该数据引擎有个很酷的特性就是在 CRUD 中支持类似 GraphQL 这样的功能（即数据模式表达式），所以我需要写一个类 GraphQL 的解析器，这应该算是一个很有价值的案例。 如上，手写各种“表达式”解析器是很有现实意义和价值的。 源码 通用词法解析模块（语法解析及编译器暂未实现） https://github.com/Zongsoft/Zongsoft.CoreLibrary/tree/master/src/Expressions 成员访问表达式解析器 https://github.com/Zongsoft/Zongsoft.CoreLibrary/tree/feature-data/src/Reflection/Expressions 数据模式表达式解析器 https://github.com/Zongsoft/Zongsoft.CoreLibrary/blob/feature-data/src/Data/SchemaParser.cs 基础知识BNF(Backus-Naur Form)巴克斯范式，在计算机科学领域，BNF 是一种适用于上下文无关的语法的符号表述，常用于描述计算编程语言的语法（文法）、文档格式、指令集以及通信协议等，总之它适用于需要准确描述的地方，如果不用这个东西，我们几乎没办法准确而简洁的表述像计算机编程语言这样需要精准表达的东西。 除了基本的 BNF 以外，人们为了更简洁的表达而进行了扩展和增强，譬如：EBNF(Extended Backus–Naur Form)、ABNF(Augmented Backus–Naur Form)，我找了几篇文章供大家参考（尤其是前三篇）： 《BNF和ABNF的含义与用法》 《语法规范：BNF与ABNF》 《EBNF:Extended Backus–Naur Form》 《ABNF:Augmented BNF for Syntax Specifications(rfc5234)》 《C# Language Specification》*(应用BNF最强大的范例：C#语言规范) * 除非是去写编程语言的编译器，通常我们不用阅读和编写像 YACC(Yet Another Compiler Compiler) 或 ANTLR(ANother Tool for Language Recognition) 这些工具中的那些非常“精准”的 BNF 的语法。有关 YACC 和 ANTLR 的一个具体案例，我推荐下面这篇文章（不用抠细节，主要关注语法定义部分）： 《TiDB 源码阅读系列文章（五）TiDB SQL Parser 的实现》 我推荐大家阅读和采用各 SQL 手册中使用的 BNF 方言来学习应用，因为它们语法约定简单，对付一般应用场景足够用。下面是它们的链接（个人比较偏好我软的 Transact-SQL），敬请食用。 Transact-SQL 语法约定 https://docs.microsoft.com/zh-cn/previous-versions/sql/sql-server-2012/ms177563(v=sql.110) PostgreSQL 手册 https://www.postgresql.org/docs/10/static/index.html MySQL 手册 https://dev.mysql.com/doc/refman/8.0/en Oracle 手册 https://docs.oracle.com/en/database/oracle/oracle-database/18/sqlrf 语法规范关于“成员访问表达式”的详细语法（文法）可以参考《C#语言规范》，下面让我们先看看之前写的那个成员表达式的例子： 1234PropertyA.ListProperty[100].MethodA(PropertyB, 'String\\'Constant for Arg2', 200, ['key'].XXX.YYY).Children['arg1', PropertyC.Foo] 我尝试用自然语言来表述上面代码的意思： 访问某个对象中名为 PropertyA 的成员（属性或字段）； 访问上面成员值对象中名为 ListProperty 的成员（该成员为列表类型或该成员所属类型有个索引器）； 访问上面成员值对象中名为 MethodA 的方法（方法的参数数目不限，此例为4个参数）； 访问上面方法返回值对象中名为 Children 的成员（该成员为列表类型或该成员所属类型有个索引器）。 补充说明： 方法参数数量不定（零或多个），参数类型可以是常量（字符串、数字）或成员访问表达式； 列表属性或索引器参数至少一个多则不限，参数类型同方法参数； 字符串常量使用单引号或双引号标注，支持 \\ 反斜杠转义符； 数字常量支持尾缀标注，即“L”表示长整型、“M”或“m”表示 decimal 类型等。 如上，即使我写了这么长篇的文字，依然没有精确而完整的完成对“成员表达式”的语法表达，可见我们必须借助 BNF 这样东西才能进行精准表达。下面是它的 BNF 范式（采用的是 Transact-SQL 语法规范）： 12345678expression ::= &#123;member | indexer&#125;[.member | indexer][...n]member ::= identifier | methodindexer ::= &quot;[&quot; &#123;expression | constant&#125;[,...n] &quot;]&quot;method ::= identifier([expression | constant][,...n])identifier ::= [_A-Za-z][_A-Za-z0-9]*constant ::= &quot;string constant&quot; | numbernumber ::= [0-9]+&#123;.[0-9]&#125;?[L|m|M|f|F] 如上，即使我们采用的不是能直接生成词法解析器(Parser)的“高精准”的 BNF 表达式，但它依然足够精确、简洁。 状态机图有了确切的语法规范/文法（即 BNF 范式表达式）之后，我们就可以有的放矢的绘制表达式解析器的状态机图了。 状态说明： Identifier：标识态，表示处于成员（属性、字段、方法）名称状态； Separator：分隔符态，表示处于成员分隔符（即圆点）状态； Gutter：空隙态，表示索引器或方法参数结束后，所处于的空隙状态； Indexer：索引器态，表示处于的索引器内部的就绪状态，它可以继续接受一个有效的非终结符，也可以是一个终结符； Parameter：参数态，表示处于索引器或方法参数的完结状态，它必须等待一个终结符（逗号或括号）； String：字符串常量态，表示处于字符串常量的内部，它可以接受任意字符，如果遇到终结符（匹配的单引号或双引号）则转入参数态； Number：数字常量态，表示处于数字字面量，它可以接受任意数字字符，如果遇到终结符（尾缀符）则转入参数态。 因为方法和索引器的参数有可能是表达式，因此在实现上需要进行递归栈处理，所以流程图中标有压栈(Push)、出栈(Pop)的行为，通过虚线表示对应的激发操作。所有左方括号 [ 通路会激发压栈操作，同时右方括号 ] 通路会激发对应的出栈操作；因为版面问题，上述流程图并没有标注出圆括号（方法参数）通路的出入栈的部分，但是逻辑等同于方括号（索引器）部分。 提示： 如果在状态迁移判定中出现状态图中未定义的字符，则表示输入参数有特定的语法错误。 如果当文本解析完成时递归栈仍不为空，则说明索引器或方法的参数没有匹配完毕。 关于解析器状态机的设计，我没有发现具有普适性的设计指导方案，大家可以根据自己的理解设定不同于上图的状态定义；至于对状态设置粒度的把握，总体原则是要具备逻辑或概念上的自恰性、并方便绘图和编程实现就可以了。 源码解析位于 Zongsoft.Reflection.Expressions 命名空间中的接口和类整体上与 System.Linq.Expressions 命名空间中的相关类的设计类似。大致类图如下： 提供解析功能的是 MemberExpressionParser 这个内部静态类（状态机类），它的 Parse(string text) 即为状态驱动函数，它遍历输入参数的文本字符，交给具体的私有方法 DoXXX(context) 进行状态迁移判定，如此循环即完成整个解析工作，整体结构与《代码失控与状态机（上）》中介绍的状态机的程序结构一致，具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public static IMemberExpression Parse(string text, Action&lt;string&gt; onError)&#123; if(string.IsNullOrEmpty(text)) return null; //创建解析上下文对象 var context = new StateContext(text.Length, onError); //状态迁移驱动 for(int i = 0; i &lt; text.Length; i++) &#123; context.Character = text[i]; switch(context.State) &#123; case State.None: if(!DoNone(ref context, i)) return null; break; case State.Gutter: if(!DoGutter(ref context, i)) return null; break; case State.Separator: if(!DoSeparator(ref context, i)) return null; break; case State.Identifier: if(!DoIdentifier(ref context, i)) return null; break; case State.Method: if(!DoMethod(ref context, i)) return null; break; case State.Indexer: if(!DoIndexer(ref context, i)) return null; break; case State.Parameter: if(!DoParameter(ref context, i)) return null; break; case State.Number: if(!DoNumber(ref context, i)) return null; break; case State.String: if(!DoString(ref context, i)) return null; break; &#125; &#125; //获取最终的解析结果 return context.GetResult();&#125; 代码简义： 其中表示状态的枚举与上面的解析器状态机流程图的定义完全一致。 内部的 StateContext 结构用来保存解析过程中的各种数据、状态、字符缓存等，以及与上下文相关的操作方法等。 内部的 StateVector 结构用来保存解析过程中的标记开关（布尔）的状态，譬如当前数值常量的类型、当前字符是否位于字符串常量的转义符态、标识(Identifier)中间是否含有空白字符等。 其他延展在 Zongsoft.Data 数据引擎里面有个数据模式(Schema)的概念，它是一种在数据操作中定义数据形状的表达式，有点类似于 GraphQL 表达式的功能（不含查询条件）。 譬如有一个名为 Corporation 的企业实体类，它除了企业编号、名称、简称等单值属性外，还有企业法人、部门集合等这样的“一对一”和“一对多”的复合（导航）属性等。现在假设我们调用数据访问类的 Select 方法进行查询调用： 12var entities = dataAccess.Select&lt;Corporation&gt;( Condition.GreaterThanEqual(\"RegisteredCapital\", 100)); 以上代码表示查询 Corporation 实体对应的表，条件为 RegisteredCapital 注册资本大于等于100万元的记录，但缺乏表达 Corporation 实体关联的导航属性的语义。采用数据模式(Schema)来定义操作的数据形状，大致如下： 123456789101112131415var schema = @\"CorporationId, Name, Abbr, RegisteredCapital,Principal&#123;Name, FullName, Avatar&#125;,Departments:10(~Level, NumberOfPeople)&#123; Name, Manager &#123; Name, FullName, JobTitle, PhoneNumber &#125;&#125;\";var entities = dataAccess.Select&lt;Corporation&gt;( schema, Condition.GreaterThanEqual(\"RegisteredCapital\", 100) &amp; Condition.Like(\"Principal.Name\", \"钟%\")); 通过数据访问方法中的 schema 参数，我们可以方便的定义数据形状（含一对多导航属性的分页和排序设置），这样就省去了多次访问数据库进行数据遍历的操作，大大提高了运行效率，同时简化了代码。 数据模式中各成员以逗号分隔，如果是复合属性则可以用花括号来限定其内部属性集，对于一对多的复合属性，还可以定义其分页和排序设置。以下是它的 BNF 范式： 12345678910111213141516171819202122schema ::=&#123; * | ! | !identifier | identifier[paging][sorting][&quot;&#123;&quot;schema [,...n]&quot;&#125;&quot;]&#125; [,...n]identifier ::= [_A-Za-z][_A-Za-z0-9]*number ::= [0-9]+paging ::= &quot;:&quot;&#123; &#123;*|?&#125;| number[/&#123;?|number&#125;]&#125;sorting ::=&quot;(&quot; &#123; [~|!]identifier &#125;[,...n]&quot;)&quot; 提示：惊叹号表示排除的意思，一个惊叹号表示排除之前的所有成员定义；以惊叹号打头的成员标识，表示排除之前定义的该成员（如果之前有定义的话，没有则忽略）。 分页设置的释义： * 返回所有记录（即不分页）；? 返回第一页，页大小为系统默认值，等同于 1/? 格式（数据引擎默认设置）；n 返回 n 条记录，等同于 1/n 格式；n/m 返回第 n 页，每页 m 行；n/? 返回第 n 页，页大小为系统默认值； 以上是数据模式表达式的解析器状态机图，具体实现代码这里就不再赘述，总体上跟“成员访问表达式”解析器类似。 结尾在很多应用状态机场景的编程中，绘制一个状态机图对于实现是具有非常重要的指导意义，希望通过这两个具体的案例能对大家有所启示。 其实 Linux/Unix 中的命令行，也是一个很好的案例，有兴趣的可以尝试写下它的 BNF 和解析状态机图。 这次我们介绍了文本解析相关的状态机的设计和实现，其实还有与工作流相关的通用状态机也是一个非常有趣的应用场景，通用状态机可以应用在游戏、工作流、业务逻辑驱动等方面。去年下半年因为业务线的需要，我花了差不多一两个礼拜的时间实现了一个完备的通用状态机，自我感觉设计得不错，但因为时间局促，在状态泛型实现上有个小瑕疵，以后做完优化后再来介绍它的架构设计和实现，这个系列就先且到此为止罢。","categories":[{"name":"zongsoft","slug":"zongsoft","permalink":"http://zongsoft.com/categories/zongsoft/"}],"tags":[{"name":"coding","slug":"coding","permalink":"http://zongsoft.com/tags/coding/"},{"name":"out of control","slug":"out-of-control","permalink":"http://zongsoft.com/tags/out-of-control/"},{"name":"state machine","slug":"state-machine","permalink":"http://zongsoft.com/tags/state-machine/"},{"name":"expression parser","slug":"expression-parser","permalink":"http://zongsoft.com/tags/expression-parser/"}]},{"title":"代码失控与状态机（上）","slug":"coding-outcontrol-statemachine-1","date":"2018-08-05T11:20:00.000Z","updated":"2019-11-17T17:45:00.624Z","comments":true,"path":"zh-cn/zongsoft/coding-outcontrol-statemachine-1/","link":"","permalink":"http://zongsoft.com/zh-cn/zongsoft/coding-outcontrol-statemachine-1/","excerpt":"","text":"前言前几天和某某同学吃饭席间，他聊到每当要修改老项目中自己写的代码时就痛苦不堪，问我是不是也有同感。我觉得这应该是不少程序猿的心声，之所以会这样，大致有两个主因： 项目的整体设计很糟糕，只管往上堆砌各种功能、补丁，对于代码质量和结构关系基本无暇顾及，最终积重难返滑向失控。 对技术缺乏必要的敬畏心，基础不够扎实、知识面较窄，不能（无法）进行合理的规划，最终导致停留在低水平的代码堆砌上，只求完成功能就万事大吉。 程序猿饭桌上总少不了对产品经理的吐槽：“产品经理又对业务流程进行了疯狂调整，我觉得这会导致状态机无法支持了。”他的这个槽点让我一时有些语塞，倒不是怀疑产品经理的脑洞还能大到把状态机开到失控，只是诧异难道我们还有比状态机更适合应对业务流程变更的武器吗？ 事实上状态机对于软件工程师来说应该是个很基础的知识点，它原理简单却拥有强大的适应力并被广泛应用 （譬如：游戏开发、工作流、编译器、正则表达式等解析器中） ，掌握好它的原理和应用，能帮助我们从容应对很多棘手问题，它于程序猿应对复杂流程性问题，就好比医生使用抗生素应对细菌感染一样的最佳武器。同时，它还是防止代码失控的一剂良药。 基本概念状态机一般泛指“有限状态机(Finite State Machine)”，《离散数学》中有关于它的专门章节，以下谨为我对相关概念的形式上的非精准释义，如有出入请以教科书或相关学术资料为准。 状态：顾名思义表示某个时刻系统处于一个特定的阶段。通常我们不考虑中间态，也可以把中间态进行退化处理。当状态发生变更，就叫状态转换(Transfer)或状态迁移(Transition)。 事件：驱动系统进行状态转换/迁移的源，提供这种源的也常被称为“触发器(Trigger)”。 行为：当系统进行状态转换时进行的响应处理，提供响应处理的程序也常被称为“处理器(Handler)”。 有了上面的基本概念，我们来看一个最简单的状态图： 你可能会奇怪这个图怎么跟网上那些状态机图不一样，连状态转换条件都没有呢？这是因为，我觉得在了解状态机之前，最好先将确立以下两种概念： 状态驱动： 状态机负责根据输入来驱动状态流转。 迁移判定： 在状态流转过程中确定当前状态是否需要进行转换/迁移，以及转换/迁移到哪个状态中的判定机制。 所以，在常见的状态机图中标注的那些状态转换条件只是“迁移判定”的一种具体表现形式，它即可以由状态机内置，也可以是独立的判定器来处理，又或者由状态图预先定义好，如此等等。 建立“状态驱动”和“迁移判定”这两个被抽象化的概念，有助于我们深入理解状态机的机理，并且对我们设计一个鲁棒性和扩展性更好到状态机有实际指导意义。 状态机图以下是表示一个‘简陋’的 Email 地址格式的解析器状态图，状态迁移条件采用正则表达式来表达，其中图二又称为“状态迁移图”。 图一：节点式 图二：表格式（红色格表示拒绝或异常；灰色格表示忽略或无意义；其他表示迁移条件） 代码实现有了上面的状态图，就像建筑工人拿到了详细的建筑设计图纸；现在我们只需要对着状态机图，把它映射成代码即可完成一个基本状态机。状态机图越详细，实现起来就越容易，同时代码的可维护性也越好。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class Email&#123; public string Identifier &#123; get; private set;&#125; public string Host &#123; get; private set; &#125; public string Domain &#123; get; private set; &#125; private Email() &#123;&#125; public static Email Parse(string text) &#123; if(string.IsNullOrEmpty(text)) return null; var state = State.None; /* The State-Driven */ for(int i=0; i&lt;text.Length; i++) &#123; var chr = text[i]; switch(state) &#123; case State.None: //do state transition decision break; case State.Identifier: //do state transition decision break; case State.Delimiter: //do state transition decision break; case State.Host: //do state transition decision break; case State.Dot: //do state transition decision break; case State.Domain: //do state transition decision break; &#125; &#125; return new Email(...); &#125; private enum State &#123; None, Identifier, Delimiter, Host, Dot, Domain, &#125;&#125; 上面的代码虽然看起来没什么技术含量，但它已经具备了一个状态机最基本的三大要素了（状态、状态驱动、迁移判定），针对具体业务场景我们只需完善和优化它的程序结构，底层原理的基本要义其实就是这么简单。 失控的大脑人脑是一个很神奇的存在，它很擅长处理抽象思维，对于逻辑推理也有很好的应对能力，但却有个不擅长处理并发任务的Bug。比如当面临很多个逻辑分支，各分支的判定条件彼此关联，大脑很快就会陷入繁杂的状态中无法自拔。 表现在解决复杂流程相关的任务时就是，写着写着你会发觉脑子好像不够用了，而程序中的 Bug 却像打地鼠游戏中的老鼠一样层出不穷。不难想象，即使脑力过人的你在勉强写完后的某天，产品经理带着他的脑洞又来找你了，在他的威逼利诱下你打开了一个月前的代码，忽然，觉得还是抱着产品经理同归于尽算了…… 这大概是某某同学，面对自己曾经的代码时痛苦的根源所在，因为普通人面对复杂流程问题时，终归受人脑算力所限。本质上这是人脑算力有限的一个困境，人类解决这个困境的一个行之有效的办法就是“分而治之”，即将一个大问题或复杂问题不断进行分解分化，直至达到人脑能相对轻松理解和处理的程度。 为什么说状态机是解决此类问题的一剂良药？ 通过状态机图可以很容易的看到它天生具有“分解、分化”的特征，一个复杂的流程由多个流程节点组成，这些节点可以理解为对流程的分解，流程节点之间的转移条件（迁移判定）可以看成是被分化后的逻辑分支，如果大脑直接处理整个流程很容易陷入纷扰的流程分支和各种细节中，但是，当我们把眼光聚焦在某个流程节点和它的转移条件上的时候，大脑需要处理的信息量就变得非常少了。 所以，当我们直面一个繁杂的流程图的时候，第一感觉就是复杂、脑阔痛，这其实是大脑的正常反应，当你把眼光聚焦到“Start”节点上，并顺着它往下推，每个节点的信息量一定是大脑能轻松处理的量级，这种顺藤摸瓜的方式反过来也正是流程设计的套路。我有时会被自己刚画完的状态机图给惊讶到，怎么这么复杂？因为当我一点点把细节补充上去后，整体性自然会变得复杂了，但是局部依然是简单的，而简单就是可靠、鲁棒、可维护性的同义词。 代码只是状态机图的相关元素的一种表现形式，它与“节点式”或“表格式”的状态机图并无本质不同。 另外，状态机图相对代码而言，它更专注于流程本身，而代码毕竟是具体实现层面的东西，除了流程本身还包括程序结构、业务代码等与流程无关的代码，这些额外的东西对我们解读流程造成了干扰，因而相对纯粹的状态机图就好比是代码实现的“地图”。经过一段时间后，我们可能已经不记得实现细节了，这时看着状态机图来进行代码解读和修改将会大大提高效率和准确度，这就是提升代码可维护性的有力手段。 如上，状态机是防止代码失控的一剂良药，制备完善的状态机图就是防止代码失控的一种有效手段。 课后作业试着脱离状态机图撸一个“成员访问表达式”的解析器去体验下失控的感受。下次，我们将一起来实现这个东西。 附注：成员访问表达式：访问对象方法、属性、字段、索引器（包括字典、列表）这些成员的表达式，其中方法和索引器（包括字典、列表）的参数支持常量和成员表达式（即表达式递归）。详细的文法请参考C#语言手册。譬如： 1234PropertyA.ListProperty[100].MethodA(PropertyB, 'StringConstant for Arg2', 200, ['key']).Children['arg1', 'arg2']","categories":[{"name":"zongsoft","slug":"zongsoft","permalink":"http://zongsoft.com/categories/zongsoft/"}],"tags":[{"name":"coding","slug":"coding","permalink":"http://zongsoft.com/tags/coding/"},{"name":"out of control","slug":"out-of-control","permalink":"http://zongsoft.com/tags/out-of-control/"},{"name":"state machine","slug":"state-machine","permalink":"http://zongsoft.com/tags/state-machine/"}]},{"title":"实体类的动态生成（三）","slug":"entity-dynamic-generation-3","date":"2018-07-16T16:00:00.000Z","updated":"2019-11-17T17:45:00.625Z","comments":true,"path":"zh-cn/zongsoft/entity-dynamic-generation-3/","link":"","permalink":"http://zongsoft.com/zh-cn/zongsoft/entity-dynamic-generation-3/","excerpt":"","text":"前言在 .NET 中主要有两种动态生成并编译的方式，一种是通过 System.Linq.Expressions 命名空间中的 LambdaExpression 类的 CompileToMethod(...) 方法，但是这种方法只支持动态编译到静态方法，因为这个限制我们只能放弃它而采用 Emitting 生成编译方案，虽然 Emitting 方案强大但是实现起来麻烦不少，必须要手动处理底层 IL 的各种细节，脑补一些 C# 编译器的实现机理，同时还要了解一些基本的 IL(Intermediate Language) 和 CLR(JVM) 执行方面的知识。 基础知识因为要采用 Emitting 技术方案，必然需要了解 IL，如果你之前没有怎么接触过，也不用灰心，网上有大量关于 IL 的入门文章，“30分钟入门”还是没问题的哈，毕竟 IL 相对 8086/8088 汇编来说，真的平易近人太多了。 首先你需要一个类似 ILSpy(http://ilspy.net) 这样的工具来查看生成的IL或反编译程序集，最近版本还会提供 IL 与对应 C# 的比照解释，用户体验真是体贴得不要不要的。 一、不同于 8086/8088 这样基于寄存器的指令集，IL 和 Java 字节码一样都是基于栈的指令集，它们最明显的区别就是指令的参数指定方式的差异。以“int x = 100+200”操作为例，IL 的指令序列大致是： 1234ldc.i4 100ldc.i4 200addstlocl.0 前两行代码分别将100和200这两个32位整数加载到运算栈(Evaluation Stack)中； 第3行的 add 是加法运算指令，它会从运算栈弹出(Pop)两次以得到它需要的两个操作数(Operand)，计算完成后又会将自己的计算结果压入(Push)到计算栈中，这时栈顶的元素就是累加的结果（即整数300）； 第4行的 stloc.0 是设置本地变量的指令，它会从计算栈弹出(Pop)一个元素，然后将该元素保存到特定本地变量中（本示例是第一个本地变量）。注：本地变量必须由方法预先声明。 二、基本上汇编语言或类似 IL 这样的中间指令集都没有高级语言中天经地义的 if/else、switch/case、do/while、for/foreach 这样的基本语言结构，它们只有类似 goto/jump/br 这样的无条件跳转和 br.true/br.false/beq/blt/bgt/ceq/clt/cgt 等之类的条件跳转指令，高级语言中的很多基本语言结构都是由编译器或解释器转换成底层的跳转结构的，所以在 Emitting 中我们也需要脑补编译器中这样的翻译机制，将那些 if/else、while、for 之类的翻译成对应的跳转结构。 需要特别指出的是，因为 C/C++/C#/JAVA 之类的高级语言的逻辑运算中有“短路”的内置约定，所以在转换成跳转结构时，必须留意处理这个问题，否则会破坏语义并可能导致运行时错误。 三、因为 IL 支持类名、字段、属性、方法等元素名称中包含除字母、数字、下划线之外的其他字符，所有各高级语言编译器都会利用该特性，主要是为了避免与特定高级语言中用户代码发生命名冲突，我们亦会采用该策略。 有了上面的基础知识，自己稍微花点时间阅读一些 IL 代码，再来翻阅 Zongsoft.Data.Entity 类的源码就简单了。 另外，在反编译阅读 IL 代码的时候，如果你反编译的是 Debug 版本，会发现生成的 IL 对本地变量的处理非常啰嗦，重复保存又紧接着加载本地变量的操作，这是因为编译器没有做优化导致，不用担心，换成用 Release 编译就好很多了，但是依然还是有一些手动优化的空间。 接口说明实体动态生成器类的源码位于 Zongsoft.CoreLibrary 项目中（https://github.com/Zongsoft/Zongsoft.CoreLibrary/blob/feature-data/src/Data/Entity.cs），这是一个静态类，其主要公共方法定义如下： 12345678910public static Entity&#123; public static T Build&lt;T&gt;(); public static T Build&lt;T&gt;(Action&lt;T&gt; map); public static IEnumerable&lt;T&gt; Build&lt;T&gt;(int count, Action&lt;T, int&gt; map = null); public static object Build(Type type); public static object Build(Type type, Action&lt;object&gt; map); public static IEnumerable Build(Type type, int count, Action&lt;object, int&gt; map = null);&#125; 公共的 Save() 方法是一个供调试之用的方法，它会将动态编译的程序集保存到文件中，以便使用 ILSpy 这样的工具反编译查看，待 feature-data 合并到 master 分支之后会被移除。 关于跑分在 https://github.com/Zongsoft/Zongsoft.CoreLibrary/blob/feature-data/samples/Zongsoft.Samples.Entities/Program.cs 类中的 PerformanceDynamic(int count) 是动态生成的跑分（性能测试）代码，需要注意的是，如果是首次动态创建某个实体接口，内部会先进行动态编译。 下面这两种方式跑分测试方式会有不同的性能表现，大家先琢磨下原因再接着往下阅读。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546private static void PerformanceDynamic(int count)&#123; // 获取构建委托，可能会触发内部的预先编译（即预热） var creator = Data.Entity.GetCreator(typeof(Models.IUserEntity)); // 创建跑分计时器 var stopwatch = new Stopwatch(); stopwatch.Start(); //开始计时 /* 第一种跑分 */ for(int i = 0; i &lt; count; i++) &#123; // 调用构建委托来创建实体类实例 var user = (Models.IUserEntity)creator(); user.UserId = (uint)i; user.Avatar = \":smile:\"; user.Name = \"Name: \" + i.ToString(); user.FullName = \"FullName\"; user.Namespace = \"Zongsoft\"; user.Status = (byte)(i % byte.MaxValue); user.StatusTimestamp = (i % 11 == 0) ? DateTime.Now : DateTime.MinValue; user.CreatedTime = DateTime.Now; &#125; stopwatch.Restart(); //重新计时 /* 第二种跑分 */ int index = 0; // 动态构建指定 count 个实体类实例（懒构建） var entities = Data.Entity.Build&lt;Models.IUserEntity&gt;(count); foreach(var user in entities) &#123; user.UserId = (uint)index; user.Avatar = \":smile:\"; user.Name = \"Name: \" + index.ToString(); user.FullName = \"FullName\"; user.Namespace = \"Zongsoft\"; user.Status = (byte)(index % byte.MaxValue); user.StatusTimestamp = (index++ % 11 == 0) ? DateTime.Now : DateTime.MinValue; user.CreatedTime = DateTime.Now; &#125; stopwatch.Stop(); //停止计时&#125; 在我的老台式机上跑一百万（即count=1,000,000）次，第二种跑分代码比第一种差不多要慢50~100毫秒左右，两者区别就在于 for 循环与 Enumerable/Enumerator 模式的区别，我曾尝试对 Build&lt;T&gt;(int count) 方法内部的 yield return （由C#编译器将该语句翻译成 Enumerable/Enumerator 模式）改为手动实现，优化的思路是：因为在这个场景中，我们已知 count 数量，基于这个必要条件可以剔除 Enumerator 循环中一些不必要的条件判断代码。但是手动写了 Enumerable/Enumerator 后发现，为了代码安全性还是无法省略一些必要的条件判断，因为不能确定用户是否会采用 entities.GetEnumerator() + while 的方式来调用，也就是说即使在确定 count 的条件下也占不到任何性能上的便宜，毕竟基本的代码安全性还是要优先保障的。 如上述所述，动态生成的代码并无性能问题，只是在应对一次性创建上百万个实体实例并遍历的场景下，为了排除 Enumerable/Enumerator 模式对性能的一点点“干扰”（这是必须的）采取了一点优化手段，在实际业务中通常不需这么处理，特此说明。 使用说明将原有业务系统中各种实体类改为接口，这些接口可以继承自 Zongsoft.Data.IEntity 也可以不用，不管实体接口是否从 Zongsoft.Data.IEntity 接口继承，动态生成的实体类都会实现该接口，因此依然可以将动态创建的实体实例强制转换为该接口。 注意：实体接口中不能含有事件、方法定义，即只能包含属性定义。 变更通知如果实体需要支持属性变更通知，则实体接口必须增加对 System.ComponentModel.INotifyPropertyChanged 接口的继承，但这样的支持需要付出一点点性能成本，以下是动态生成后的部分C#代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243public interface IPerson&#123; string Name &#123; get; set; &#125;&#125;// 不支持的属性变更通知版本public class Person : IPerson, IEntity&#123; public string Name &#123; get =&gt; _name; set =&gt; &#123; _name = value; _MASK_ |= 1; &#125; &#125;&#125;/* 增加对属性变更通知的特性 */public interface IPerson : INotifyPropertyChanged&#123; string Name &#123; get; set; &#125;&#125;// 支持属性变更通知版本public class Person : IPerson, IEntity, INotifyPropertyChanged&#123; // 事件声明 public event PropertyChangedEventHandler PropertyChanged; public string Name &#123; get =&gt; _name; set =&gt; &#123; if(_name == value) // 新旧值比对判断 return; _name = value; _MASK_ |= 1; this.PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(\"Name\")); &#125; &#125;&#125; 所谓一点点性能成本有两点：①需要对新旧值进行比对，比对方法的实现性能对此处有至关影响；②对 PropertyChanged 事件的有效性判断并调用事件委托。当然，如果这是必须的 feature 需求，那就无所谓成本了。 提示：关于新旧值比对的说明，如果属性类型是基元类型，动态生成器会生成 bne/be 这样的特定 IL 指令；否则如果该类型重写了 == 操作符则会使用该操作符的实现；否则会调用 Object.Equals(…) 静态方法来比对。 扩展属性在某些场景，需要手动处理属性的 getter 或 setter 的业务逻辑，那该如何在动态生成中植入这些逻辑代码呢？在 Zongsoft.Data.Entity 类中有个 PropertyAttribute 自定义特性类，可以利用它来声明扩展属性的实现。譬如下面的示例： 123456789101112131415161718192021222324252627282930313233343536373839404142public static UserExtension&#123; public static string GetAvatarUrl(IUser user) &#123; if(string.IsNullOrEmpty(user.Avatar)) return null; return \"URL:\" + user.Avatar; &#125;&#125;public interface IUser&#123; string Avatar &#123; get; set; &#125; [Entity.Property(Entity.PropertyImplementationMode.Extension, typeof(UserExtension))] string AvatarUrl &#123; get; &#125;&#125;/* 以下的 User 实体类为动态生成器生成的部分示意代码。*/public class User : IUser, IEntity&#123; private string _avatar; public string Avatar &#123; get =&gt; _avatar; set &#123; _avatar = value; _MASK_ |= xxx; &#125; &#125; public string AvatarUrl &#123; get &#123; return UserExtension.GetAvatarUrl(this); &#125; &#125;&#125; 上面的代码比较好理解，就不多说，如果 IUser 接口中的 AvatarUrl 属性是可读写属性或者有 System.ComponentModel.DefaultValueAttribute 自定义特性修饰，那么该属性就会有对应的字段，对应的属性扩展方法也可以获取该字段值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static class UserExtension&#123; public static string GetAvatarUrl(IUser user, string value) &#123; if(string.IsNullOrEmpty(value)) return $\"http://...&#123;user.Avatar&#125;...\"; return value; &#125;&#125;public interface IUser&#123; string Avatar &#123; get; set; &#125; [Entity.Property(Entity.PropertyImplementationMode.Extension, typeof(UserExtension))] string AvatarUrl &#123; get; set; &#125;&#125;/* 以下的 User 实体类为动态生成器生成的部分示意代码。*/public class User : IUser, IEntity&#123; private string _avatar; private string _avatarUrl; public string Avatar &#123; get =&gt; _avatar; set &#123; _avatar = value; _MASK_ |= xxx; &#125; &#125; // 只有读取获取扩展方法 public string AvatarUrl &#123; get =&gt; Extension.GetAvatarUrl(this, _avatarUrl); set &#123; _avatarUrl = value; _MASK_ |= xxx; &#125; &#125;&#125; 当然扩展属性方法支持读写两种，下面是同时实现了两个版本的扩展方法的样子： 123456789101112131415161718192021222324252627282930public static class UserExtension&#123; public static string GetAvatarUrl(IUser user, string value) &#123; throw new NotImplementedException(); &#125; public static bool SetAvatarUrl(IUser user, string value) &#123; throw new NotImplementedException(); &#125;&#125;/* 以下的 User 实体类为动态生成器生成的部分示意代码。*/public class User : IUser, IEntity&#123; public string AvatarUrl &#123; get =&gt; UserExtension.GetAvatarUrl(this, _avatarUrl); set &#123; if(UserExtension.SetAvatarUrl(this, _avatarUrl)) &#123; _avatarUrl = value; _MASK_ |= xxx; &#125; &#125; &#125;&#125; 扩展属性方法的定义约定： 必须是一个公共的静态方法； 读取方法名以 Get 打头，后面接扩展属性名并区分大小写； 读取方法的第一个参数必须是要扩展实体接口类型，第二个参数可选，如果有的话必须是扩展属性的类型；返回类型必须是扩展属性的类型； 设置方法名以 Set 打头，后面接扩展属性名并区分大小写； 设置方法的第一个参数必须是要扩展实体接口类型，第二参数是扩展属性的类型，表示设置的新值；返回类型必须是布尔类型，返回真(True)表示设置成功否则返回失败(False)，只有返回真对应的成员字段才会被设置更新。 单例模式某些场景中，属性需要采用单例模式来实现，譬如一些集合类型的属性。 12345678910111213141516171819202122232425262728293031323334public interface IDepartment&#123; [Entity.Property(Entity.PropertyImplementationMode.Singleton)] ICollection&lt;IUser&gt; Users &#123; get; &#125;&#125;/* 以下的 Department 实体类为动态生成器生成的部分示意代码。*/public class Department : IDepartment, IEntity&#123; private readonly object _users_LOCK; private ICollection&lt;IUser&gt; _users; public Department() &#123; _users_LOCK = new object(); &#125; public ICollection&lt;IUser&gt; Users &#123; get &#123; if(_users == null) &#123; lock(_users_LOCK) &#123; if(_users == null) &#123; _users = new List&lt;IUser&gt;(); &#125; &#125; &#125; return _users; &#125; &#125;&#125; 实现采用的是双检锁模式，必须注意到，每个单例属性都会额外占用一个用于双检锁的 object 类型变量。如果属性类型是集合接口，那么动态生成器会选择一个合适的实现该接口的集合类；当然，你也可以自定义一个工厂方法来创建对应的实例，在实体属性中通过 PropertyAttribute 自定特性中声明工厂方法所在的类型即可。 注意：工厂方法必须是一个公共的静态方法，有一个可选的参数，参数类型为实体接口类型。 123456789101112131415161718192021222324252627282930313233343536373839404142public static class DepartmentExtension&#123; public static ICollection&lt;IUser&gt; GetUsers(IDepartment department) &#123; return new MyUserCollection(department); &#125;&#125;public interface IDepartment&#123; [Entity.Property(Entity.PropertyImplementationMode.Singleton, typeof(DepartmentExtension))] ICollection&lt;IUser&gt; Users &#123; get; &#125;&#125;/* 以下的 Department 实体类为动态生成器生成的部分示意代码。*/public class Department : IDepartment, IEntity&#123; private readonly object _users_LOCK; private ICollection&lt;IUser&gt; _users; public Department() &#123; _users_LOCK = new object(); &#125; public ICollection&lt;IUser&gt; Users &#123; get &#123; if(_users == null) &#123; lock(_users_LOCK) &#123; if(_users == null) &#123; _users = DepartmentExtension.GetUsers(this); &#125; &#125; &#125; return _users; &#125; &#125;&#125; 默认值和自定义初始化有时我们需要只读属性，但又不需要单例模式这种相对较重的实现机制，可以采用 DefaultValueAttribute 这个自定义特性来处理这种情况。 提示：实体接口或属性声明的所有自定义特性都会被生成器添加到实体类的对应元素中，后面的演示代码可能会省略这些生成的自定义特性，特此说明。 123456789101112131415161718192021222324252627282930313233343536373839public interface IDepartment&#123; [DefaultValue(\"Popeye\")] string Name &#123; get; set; &#125; [DefaultValue] ICollection&lt;IUser&gt; Users &#123; get; &#125;&#125;/* 以下的 Department 实体类为动态生成器生成的部分示意代码。*/public class Department : IDepartment, IEntity&#123; private string _name; private ICollection&lt;IUser&gt; _users; public Department() &#123; _name = \"Popeye\"; _users = new List&lt;IUser&gt;(); &#125; [DefaultValue(\"Popeye\")] public string Name &#123; get =&gt; _name; set &#123; _name = value; _MASK_ |= xxx; &#125; &#125; [DefaultValue()] public ICollection&lt;IUser&gt; Users &#123; get =&gt; _users; &#125;&#125; 除了支持固定(Mutable)默认值，还支持动态(Immutable)的，所谓动态值是指它的值不在 DefaultValueAttribute 中被固化，即指定 DefaultValueAttribute 的值为一个静态类的类型，该静态类中必须有一个名为 Get 打头并以属性名结尾的方法，该方法可以没有参数，也可以有一个实体接口类型的参数，如下所示。 12345678910111213141516171819202122232425262728293031public static DepartmentExtension&#123; public static DateTime GetCreationDate() &#123; return DateTime.Now; &#125;&#125;public interface IDepartment&#123; [DefaultValue(typeof(DepartmentExtension))] DateTime CreationDate &#123; get; &#125;&#125;/* 以下的 Department 实体类为动态生成器生成的部分示意代码。*/public class Department : IDepartment, IEntity&#123; private DateTime _creationDate; public Department() &#123; _creationDate = DepartmentExtension.GetCreationDate(); &#125; public DateTime CreationDate &#123; get =&gt; _creationDate; &#125;&#125; 如果 DefaultValueAttribute 默认值自定义特性中指定的是一个类型(即 System.Type)，并且该类型不是一个静态类的类型，并且属性类型也不是 System.Type 的话，那则表示该类型为属性的实际类型，这对于某些属性被声明为接口或基类的情况下尤为有用，如下所示。 12345678910111213141516171819202122232425262728293031323334public interface IDepartment&#123; [DefaultValue(typeof(MyManager))] IUser Manager &#123; get; set; &#125; [DefaultValue(typeof(MyUserCollection))] ICollection&lt;IUser&gt; Users &#123; get; &#125;&#125;/* 以下的 Department 实体类为动态生成器生成的部分示意代码。*/public class Department : IDepartment, IEntity&#123; private IUser _manager; private ICollection&lt;IUser&gt; _users; public Department() &#123; _managert = new MyManager(); _users = new MyUserCollection(); &#125; public IUser Manager &#123; get =&gt; _manager; set =&gt; _manager = value; &#125; public ICollection&lt;IUser&gt; Users &#123; get =&gt; _users; &#125;&#125; 其他说明默认生成的实体属性为公共属性（即非显式实现方式），当出现实体接口在继承中发生了属性重名，或因为某些特殊需求导致必须对某个实体属性以显式方式实现，则可通过 Entity.PropertyAttribute 自定特性中的 IsExplicitImplementation=true 来开启显式实现机制。 在实体接口中声明的各种自定义特性(Attribute)，都会被动态生成器原样添加到生成的实体类中。因此之前范例中，凡是接口以及接口的属性声明的各种自定义特性（包括：DefaultValueAttribute 、 Entity.PropertyAttribute ）都会被添加到动态生成的实体类的相应元素中，这对于某些应用是一个必须被支持的特性。 性能测试在《实体类的动态生成（二）》中，我们已经验证过设计方案的执行性能了，但结合上面介绍的功能特性细节，还需再提醒的是：因为开启 DefaultValueAttribute 、扩展属性方法、单例属性、属性变更通知都会导致生成的代码与最基本字段访问方式有所功能增强，对应要跑的代码量增多，因此对跑分是有影响，但这种影响是确定可知的，它们是 feature 所需并非实现方案、算法缺陷所致，敬请知晓。 譬如图二就是增加了属性变更通知（即实体接口继承了 INotifyPropertyChanged ）导致的性能影响（Dynamic Entity 所在行）。 写在最后的话该实体类动态生成器简单易用、运行性能和内存利用率都非常不错（包括提供 IEntiy 接口的超赞功能），将会成为今后我们所有业务系统的基础结构之一，所以后续的文章中（如果还有的话）应该会经常看到它的应用。 算下来花了整整三天时间（白天晚上都在写）才完成《实体类的动态生成》系列文章，真心觉得写文章比写代码还累，而且这还是省略了应该配有的一些流程图、架构图的情况下。计划接下来我会为 Zongsoft(https://github.com/Zongsoft) 系列开源项目撰写该有的所有文档，照这次这个写法，心底不由升起一丝莫名恐惧和淡淡忧伤来。 如果你觉得这次的文章对你有所帮助，又或者你觉得我们的开源项目做的还不错，请务必为我们点赞并关注我们的公众号，这或许是我坚持写下去的最大动力来源了。 最后，因为写这个东西耽搁了不少造 Zongsoft.Data 这个轮子的时间，所以接下来得全力去造轮子了。打算每周至少一篇干货满满的技术文章在公众号首发，希望不会让自己失望吧。 关于 Zongsoft.Data 它一定会是一款性能满血、易用且足够灵活的数据引擎，首发即会支持四大关系型数据库，后续会加入对 __Elasticsearch __的支持，总之，它应该是不同于市面上任何一款 ORM 数据引擎的开源产品。我会陆续与大家分享有关它的一些设计思考以及实现中遇到的问题，当然，也可以在 github 上围观我的进展。","categories":[{"name":"zongsoft","slug":"zongsoft","permalink":"http://zongsoft.com/categories/zongsoft/"}],"tags":[{"name":"entity","slug":"entity","permalink":"http://zongsoft.com/tags/entity/"},{"name":"emit","slug":"emit","permalink":"http://zongsoft.com/tags/emit/"},{"name":"dynamic","slug":"dynamic","permalink":"http://zongsoft.com/tags/dynamic/"},{"name":"generate","slug":"generate","permalink":"http://zongsoft.com/tags/generate/"},{"name":"compile","slug":"compile","permalink":"http://zongsoft.com/tags/compile/"},{"name":"实体","slug":"实体","permalink":"http://zongsoft.com/tags/%E5%AE%9E%E4%BD%93/"},{"name":"动态编译","slug":"动态编译","permalink":"http://zongsoft.com/tags/%E5%8A%A8%E6%80%81%E7%BC%96%E8%AF%91/"},{"name":"动态生成","slug":"动态生成","permalink":"http://zongsoft.com/tags/%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90/"}]},{"title":"实体类的动态生成（二）","slug":"entity-dynamic-generation-2","date":"2018-07-15T16:00:00.000Z","updated":"2019-11-17T17:45:00.625Z","comments":true,"path":"zh-cn/zongsoft/entity-dynamic-generation-2/","link":"","permalink":"http://zongsoft.com/zh-cn/zongsoft/entity-dynamic-generation-2/","excerpt":"","text":"前言由于采用字典的方式来保存属性变更值的底层设计思想，导致了性能问题，虽然.NET的字典实现已经很高效了，但相对于直接读写字段的方式而言依然有巨大的性能差距，同时也会导致对属性的读写过程中产生不必要的装箱和拆箱。那么这次我们就来彻底解决这个问题，同时还要解决“哪些属性发生过变更”、“获取变更的属性集”这些功能特性，所以我们先把接口定义出来，以便后续问题讲解。 1234567891011121314151617181920212223242526272829303132333435363738/* 源码位于 Zongsoft.CoreLibary 项目的 Zongsoft.Data 命名空间中 *//// &lt;summary&gt; 表示数据实体的接口。&lt;/summary&gt;public interface IEntity&#123; /// &lt;summary&gt; /// 判断指定的属性或任意属性是否被变更过。 /// &lt;/summary&gt; /// &lt;param name=\"names\"&gt;指定要判断的属性名数组，如果为空(null)或空数组则表示判断任意属性。&lt;/param&gt; /// &lt;returns&gt; /// &lt;para&gt;如果指定的&lt;paramref name=\"names\"/&gt;参数有值，当只有参数中指定的属性发生过更改则返回真(True)，否则返回假(False)；&lt;/para&gt; /// &lt;para&gt;如果指定的&lt;paramref name=\"names\"/&gt;参数为空(null)或空数组，当实体中任意属性发生过更改则返回真(True)，否则返回假(False)。&lt;/para&gt; /// &lt;/returns&gt; bool HasChanges(params string[] names); /// &lt;summary&gt; /// 获取实体中发生过变更的属性集。 /// &lt;/summary&gt; /// &lt;returns&gt;如果实体没有属性发生过变更，则返回空(null)，否则返回被变更过的属性键值对。&lt;/returns&gt; IDictionary&lt;string, object&gt; GetChanges(); /// &lt;summary&gt; /// 尝试获取指定名称的属性变更后的值。 /// &lt;/summary&gt; /// &lt;param name=\"name\"&gt;指定要获取的属性名。&lt;/param&gt; /// &lt;param name=\"value\"&gt;输出参数，指定属性名对应的变更后的值。&lt;/param&gt; /// &lt;returns&gt;如果指定名称的属性是存在的并且发生过变更，则返回真(True)，否则返回假(False)。&lt;/returns&gt; /// &lt;remarks&gt;注意：即使指定名称的属性是存在的，但只要其值未被更改过，也会返回假(False)。&lt;/remarks&gt; bool TryGetValue(string name, out object value); /// &lt;summary&gt; /// 尝试设置指定名称的属性值。 /// &lt;/summary&gt; /// &lt;param name=\"name\"&gt;指定要设置的属性名。&lt;/param&gt; /// &lt;param name=\"value\"&gt;指定要设置的属性值。&lt;/param&gt; /// &lt;returns&gt;如果指定名称的属性是存在的并且可写入，则返回真(True)，否则返回假(False)。&lt;/returns&gt; bool TrySetValue(string name, object value);&#125; 设计思想根本要点是取消用字典来保存属性值回归到字段方式，只有这样才能确保性能，关键问题是如何在写入字段值的时候，标记对应的属性发生过变更的呢？应用布隆过滤器(Bloom Filter)算法的思路来处理这个应用场景是一个完美的解决方案，因为布隆过滤器的空间效率和查询效率极高，而它的缺点在此恰好可以针对性的优化掉。 将每个属性映射到一个整型数（byte/ushort/uint/ulong）的某个比特位(bit)，如果发生过变更则将该 bit 置为 1，只要确保属性与二进制位顺序是确定的即可，算法复杂度是O(1)常量，并且比特位操作的效率也是极高的。 实现示范有了算法，我们写一个简单范例来感受下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127public class Person : IEntity&#123; #region 静态字段 private static readonly string[] __NAMES__ = new string[] &#123; \"Name\", \"Gender\", \"Birthdate\" &#125;; private static readonly Dictionary&lt;string, PropertyToken&lt;Person&gt;&gt; __TOKENS__ = new Dictionary&lt;string, PropertyToken&lt;Person&gt;&gt;() &#123; &#123; \"Name\", new PropertyToken&lt;Person&gt;(0, target =&gt; target._name, (target, value) =&gt; target.Name = (string) value) &#125;, &#123; \"Gender\", new PropertyToken&lt;Person&gt;(1, target =&gt; target._gender, (target, value) =&gt; target.Gender = (Gender?) value) &#125;, &#123; \"Birthdate\", new PropertyToken&lt;Person&gt;(2, target =&gt; target._birthdate, (target, value) =&gt; target.Birthdate = (DateTime) value) &#125;, &#125;; #endregion #region 标记变量 private byte _MASK_; #endregion #region 成员字段 private string _name; private bool? _gender; private DateTime _birthdate; #endregion #region 公共属性 public string Name &#123; get =&gt; _name; set &#123; _name = value; _MASK_ |= 1; &#125; &#125; public bool? Gender &#123; get =&gt; _gender; set &#123; _gender = value; _MASK_ |= 2; &#125; &#125; public DateTime Birthdate &#123; get =&gt; _birthdate; set &#123; _birthdate = value; _MASK_ |= 4; &#125; &#125; #endregion #region 接口实现 public bool HasChanges(string[] names) &#123; PropertyToken&lt;Person&gt; property; if(names == null || names.Length == 0) return _MASK_ != 0; for(var i = 0; i &lt; names.Length; i++) &#123; if(__TOKENS__.TryGetValue(names[i], out property) &amp;&amp; (_MASK_ &gt;&gt; property.Ordinal &amp; 1) == 1) return true; &#125; return false; &#125; public IDictionary&lt;string, object&gt; GetChanges() &#123; if(_MASK_ == 0) return null; var dictionary = new Dictionary&lt;string, object&gt;(__NAMES__.Length); for(int i = 0; i &lt; __NAMES__.Length; i++) &#123; if((_MASK_ &gt;&gt; i &amp; 1) == 1) dictionary[__NAMES__[i]] = __TOKENS__[__NAMES__[i]].Getter(this); &#125; return dictionary; &#125; public bool TryGetValue(string name, out object value) &#123; value = null; if(__TOKENS__.TryGetValue(name, out var property) &amp;&amp; (_MASK_ &gt;&gt; property.Ordinal &amp; 1) == 1) &#123; value = property.Getter(this); return true; &#125; return false; &#125; public bool TrySetValue(string name, object value) &#123; if(__TOKENS__.TryGetValue(name, out var property)) &#123; property.Setter(this, value); return true; &#125; return false; &#125; #endregion&#125;// 辅助结构public struct PropertyToken&lt;T&gt;&#123; public PropertyToken(int ordinal, Func&lt;T, object&gt; getter, Action&lt;T, object&gt; setter) &#123; this.Ordinal = ordinal; this.Getter = getter; this.Setter = setter; &#125; public readonly int Ordinal; public readonly Func&lt;T, object&gt; Getter; public readonly Action&lt;T, object&gt; Setter;&#125; 上面实现代码，主要有以下几个要点： 属性设置器中除了对字段赋值外，多了一个位或赋值操作（这是一句非常低成本的代码）； 需要一个额外的整型数的实例字段 _MASK_ ，来标记对应更改属性序号； 分别增加 __NAMES__ 和* *__TOKENS__ 两个静态只读变量，来保存实体类的元数据，以便更高效的实现 IEntity 接口方法。 根据代码可分析出其理论执行性能与原生实现基本一致，内存消耗只多了一个字节（如果可写属性数量小于9），由于 __NAMES__ 和 __TOKENS__ 是静态变量，因此不占用实例空间，理论上该方案的整体效率非常高。 性能对比上面我们从代码角度简单分析了下整个方案的性能和消耗，那么实际情况到底怎样呢？跑个分呗（性能对比测试代码地址：https://github.com/Zongsoft/Zongsoft.CoreLibrary/tree/feature-data/samples/Zongsoft.Samples.Entities），具体代码就不在这里占用版面了，下面给出某次在我的老旧台式机（CPU:Intel i5-3470@3.2GHz | RAM:8GB | Win10 __| __.NET 4.6）上生成100万个实例的截图： “Native Object: 295”表示原生实现版（即简单的读写字段）的运行时长（单位：毫秒，下同）； “Data Entity: 295”为本案的运行时长，通常本方案比原生方案要慢10毫秒左右，偶尔能跑平（属于运行环境抖动，可忽略）； “Data Entity(TrySet): 835”为本方案中 TrySet(...) 方法的运行时长，由于 TrySet(...) 方法内部需要进行字典查询所以有性能损耗亦属正常，在百万量级跑到这个时长说明性能也是很不错的，如果切换到 .NET Core 2.1 的话，得益于基础类库的性能改善，还能再享受一波性能红利。 综上所述，该方案付出极少的内存成本获得了与原生简单属性访问基本一致的性能，同时还提供了属性变更跟踪等新功能（即高效完成了 Zongsoft.Data.IEntity 接口中定义的那些重要功能特性），为后续业务开发提供了有力的基础支撑。 实现完善上面的实现范例代码并没有实现 INotifyPropertyChanged 接口，下面补充完善下实现该接口后的属性定义： 12345678910111213141516171819public class Person : IEntity, INotifyPropertyChanged&#123; // 事件声明 public event PropertyChangedEventHandler PropertyChanged; public string Name &#123; get =&gt; _name; set &#123; if(_name == value) return; _name = value; _MASK_ |= 1; this.PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(Name))); &#125; &#125;&#125; 如上，属性的设置器中的做了一个新旧值的比对判断和对 PropertyChanged 事件激发，其他代码没有变化。 另外，我们使用的是 byte 类型的 _MASK_ 的标记变量来保存属性的更改状态，如果当实体的属性数量超过 8 个，就需要根据具体数量换成相应的 UInt16,UInt32,UInt64 类型，但如果超过 64 就需要采用 byte[] 了，当然必须要变动下相关代码，假设以下实体类有 __100 __个属性（注意仅例举了第一个 Property1 和最后一个 Property100 属性）： 12345678910111213141516171819202122232425262728293031public class MyEntity : IEntity&#123; #region 标记变量 private readonly byte[] _MASK_; #endregion public Person() &#123; _MASK_ = new byte[13]; // 13 = Math.Ceiling(100 / 8) &#125; public object Property1 &#123; get =&gt; _property1; set &#123; _property1 = value; _MASKS_[0] |= 1; // _MASK_[0 / 8] |= (byte)Math.Pow(2, 0 % 8); &#125; &#125; public object Property100 &#123; get =&gt; _property100; set &#123; _property100 = value; _MASKS_[12] |= 8; // _MASK_[99 / 8] |= (byte)Math.Pow(2, 99 % 8); &#125; &#125;&#125; 变化内容为先根据当前属性的顺序号来确定到对应的标记数组的下标，然后再确定对应的掩码值。当然，也别忘了调整 Zongsoft.Data.IEntity 接口中各方法的实现。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class MyEntity : IEntity&#123; public bool HasChanges(params string[] names) &#123; PropertyToken&lt;UserEntity&gt; property; if(names == null || names.Length == 0) &#123; for(int i = 0; i &lt; _MASK_.Length; i++) &#123; if(_MASK_[i] != 0) return true; &#125; return false; &#125; for(var i = 0; i &lt; names.Length; i++) &#123; if(__TOKENS__.TryGetValue(names[i], out property) &amp;&amp; (_MASK_[property.Ordinal / 8] &gt;&gt; (property.Ordinal % 8) &amp; 1) == 1) return true; &#125; return false; &#125; public IDictionary&lt;string, object&gt; GetChanges() &#123; var dictionary = new Dictionary&lt;string, object&gt;(__NAMES__.Length); for(int i = 0; i &lt; __NAMES__.Length; i++) &#123; if((_MASK_[i / 8] &gt;&gt; (i % 8) &amp; 1) == 1) dictionary[__NAMES__[i]] = __TOKENS__[__NAMES__[i]].Getter(this); &#125; return dictionary.Count == 0 ? null : dictionary; &#125; public bool TryGet(string name, out object value) &#123; value = null; if(__TOKENS__.TryGetValue(name, out var property) &amp;&amp; (_MASK_[property.Ordinal / 8] &gt;&gt; (property.Ordinal % 8) &amp; 1) == 1) &#123; value = property.Getter(this); return true; &#125; return false; &#125; public bool TrySetValue(string name, object value) &#123; /* 相对之前版本没有变化 */ /* No changes relative to previous versions */ &#125;&#125; 代码变化部分比较简单，只有掩码处理部分需要调整。 新问题有了这些实现范式，定义个实体基类并在基类中完成主要功能即可推广应用了，但是，这里有个掩码类型和处理方式无法通用化实现的问题，如果要把这部分代码交由子类来实现的话，那么代码复用度会大打折扣甚至完全失去复用的意义。 为展示这个问题的艰难，在 https://github.com/Zongsoft/Zongsoft.CoreLibrary/blob/feature-data/tests/Entities.cs 源文件中，写了属性数量不等的几个实体类（Person、Customer、Employee、SpecialEmployee），采用继承方式进行复用性验证，可清晰看到实现的非常冗长繁琐，对实现者的细节把控要求很高、实现上非常容易出错，更致命的是复用度还极差。并且当实体类需要进行属性增减，是非常麻烦的，需要仔细调整原有代码结构中掩码的映射位置，这对于代码维护无意是场恶梦。 新办法解决办法其实很简单，正是本文的标题——“动态生成”，彻底解放实现者并确保实现的正确性。业务方不再定义具体的实体类，而是定义实体接口即可，实体类将由实体生成器来动态生成。我们依然“从场景出发”，先来看看业务层的使用。 123456789101112131415public interface IPerson : IEntity&#123; string Name &#123; get; set; &#125; bool? Gender &#123; get; set; &#125; DateTime Birthdate &#123; get; set; &#125;&#125;public interface IEmployee : IPerson&#123; byte Status &#123; get; set; &#125; decimal Salary &#123; get; set; &#125;&#125;var person = Entity.Build&lt;IPerson&gt;();var employee = Entity.Build&lt;IEmployee&gt;(); 总结至此，终于得到了一个兼顾性能与功能并易于使用且无需繁琐的手动实现的最终方案，虽然刚开始看起来是一个多么平常又简单的任务。那么接下来我们该怎么实现这个动态生成器呢？最终它能性能无损的被实现出来吗？请关注我们的公众号（Zongsoft）留言讨论。 敬请期待更精彩的下篇，关注我们的公众号可以第一时间看到哦！","categories":[{"name":"zongsoft","slug":"zongsoft","permalink":"http://zongsoft.com/categories/zongsoft/"}],"tags":[{"name":"entity","slug":"entity","permalink":"http://zongsoft.com/tags/entity/"},{"name":"emit","slug":"emit","permalink":"http://zongsoft.com/tags/emit/"},{"name":"dynamic","slug":"dynamic","permalink":"http://zongsoft.com/tags/dynamic/"},{"name":"generate","slug":"generate","permalink":"http://zongsoft.com/tags/generate/"},{"name":"compile","slug":"compile","permalink":"http://zongsoft.com/tags/compile/"},{"name":"实体","slug":"实体","permalink":"http://zongsoft.com/tags/%E5%AE%9E%E4%BD%93/"},{"name":"动态编译","slug":"动态编译","permalink":"http://zongsoft.com/tags/%E5%8A%A8%E6%80%81%E7%BC%96%E8%AF%91/"},{"name":"动态生成","slug":"动态生成","permalink":"http://zongsoft.com/tags/%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90/"}]},{"title":"实体类的动态生成（一）","slug":"entity-dynamic-generation-1","date":"2018-07-14T16:00:00.000Z","updated":"2019-11-17T17:45:00.625Z","comments":true,"path":"zh-cn/zongsoft/entity-dynamic-generation-1/","link":"","permalink":"http://zongsoft.com/zh-cn/zongsoft/entity-dynamic-generation-1/","excerpt":"","text":"前言在应用开发中，通常都会涉及各种 POJO/POCO 实体类（DO, DTO, BO, VO）的编写，有时这些实体类还需要实现 INotifyPropertyChanged 接口以支持属性变更通知，一般我们都会手写这些代码或者通过工具根据数据库表定义抑或别的什么模板、映射文件之类的来静态生成它们。但是，在业务实现中往往伴随着诸如“如何简单且高效的获取某个实体实例有哪些属性发生过变更？”、“变更后的值是什么？”这样的问题，而大致的解决方法有： 由实体容器来跟踪实例的属性变更； 改造实体类（譬如继承特定实体基类，在基类中实现这些基础构造）。 方法(1)需要配合一整套架构设计来提供支撑，也不是专为解决上述实体类的问题而设，并且实现和使用也都不够简单高效，故此略过不表。接下来我将通过几篇文章来详细阐述这些问题的来由以及解决方案，并给出完整的代码实现以及性能比对测试。 关于源码下面将要介绍的所有代码均位于我们的开源系列项目（地址：https://github.com/Zongsoft），项目主要采用 LGPL 2.1授权协议，欢迎大家参与并使用（请遵照授权协议）。而本文相关的源码位于其中 Zongsoft.CoreLibrary 项目的 feature-data 分支（https://github.com/Zongsoft/Zongsoft.CoreLibrary/tree/feature-data）及其中的 /samples/Zongsoft.Samples.Entities 范例项目，由于目前我正在忙着造 Zongsoft.Data 数据引擎这个轮子，不排除后面介绍到的代码会有一些调整，待该项目完成后这些代码亦会合并到 __master __分支中，敬请留意。 基础版本万里长城也是从第一块砖头开始磊起来的，就让我们来搬第一块砖吧： 123456789101112131415161718192021222324252627282930public class User&#123; private uint _userId; private string _name; // 传统写法 public uint UserId &#123; get &#123; return _userId; &#125; set &#123; _userId = value; &#125; &#125; // C# 7.0 语法 public string Name &#123; get =&gt; _name; set =&gt; _name = value; &#125; // 懒汉写法：仅限不需要操作成员字段的场景 public string Namespace &#123; get; set; &#125;&#125; 以上代码特地用了三种编码方式，它们被C#编译器生成的IL没有模式上的不同，故而性能没有任何区别，大家根据自己的口味采用某种即可，因为我们的源码由于历史原因可能会有一些混写，在此一并做个展示而已。 由于业务需要，我们希望实体类能支持属性变更通知，即让它支持 INotifyPropertyChanged 接口，这么简单的需求当然不在话下： 12345678910111213141516171819202122232425262728293031323334353637public class User : INotifyPropertyChanged&#123; public event PropertyChangedEventHandler PropertyChanged; private uint _userId; private string _name; public uint UserId &#123; get =&gt; _userId; set &#123; if(_userId == value) return; _userId = value; this.OnPropertyChanged(\"UserId\"); // 传统写法 &#125; &#125; public string Name &#123; get =&gt; _name; set &#123; if(_name == value) return; _name = value; this.OnPropertyChanged(nameof(Name)); // nameof 为 C# 7.0 新增操作符 &#125; &#125; protected virtual void OnPropertyChanged(string propertyName) &#123; // 注意 ?. 为 C# 7.0 新增操作符 this.PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName)); &#125;&#125; 一切看起来是那么完美，但是，当我们写了几个这样的实体类，尤其是有些实体类的属性还不少时，体验就有点糟糕了。自然我们会想到写个实体基类来实现属性变更通知的基础构造，当然，在某些特定场景也可以通过工具来生成类似上面这样的C#实体类文件，但工具生成的方式有一定局限性并且不易维护（譬如需要在生成的代码基础上进行特定改造），在此不再赘述。 实体基类在进行基础类库或API设计的时候，我有个建议：从应用场景开始。具体的作法是，先尝试编写使用这些API的应用代码，待各种应用场景的使用代码基本都完成后，API接口也就自然而然的确定了。譬如，在我们这个需求中我希望这么去使用实体基类： 1234567891011121314151617public class User : ModelBase&#123; private uint _userId; private string _name; public uint UserId &#123; get =&gt; _userId; set =&gt; this.SetPropertyValue(nameof(UserId), ref _userId, value); &#125; public string Name &#123; get =&gt; _name; set =&gt; this.SetPropertyValue(nameof(Name), ref _name, value); &#125;&#125; 有了这样的实体基类后，增强了功能后代码依然如第一块砖的“基础版本”一样简洁，真是高兴啊！但这就够了么，能不能把具体实体类里面的成员字段也省了，交给基类来处理呢？嗯，有点意思，试着写下应用场景代码： 12345678public class User : ModelBase&#123; public uint UserId &#123; get =&gt; (uint)this.GetPropertyValue(nameof(UserId)); set =&gt; this.SetPropertyValue(nameof(UserId), value); &#125;&#125; 看起来棒极了，代码变得更简洁了，真是天才啊！淡定，丧心病狂的 C# 设计者似乎看到了这种普遍的需求，于是在 C# 5 中增加了 System.Runtime.CompilerServices.CallerMemberNameAttribute 自定义标记，C# 编译器将自动把调用者名字生成出来传递给加注了该标记的参数，因此这样的代码还可以继续简化： 12345678public class User : ModelBase&#123; public uint UserId &#123; get =&gt; (uint)this.GetPropertyValue(); set =&gt; this.SetPropertyValue(value); &#125;&#125; 但是，属性的 getter 里面的那个类型强制转换，怎么看都像是一朵“乌云”啊，能不能把它也去掉呢？嗯，利用C#的泛型类型推断可以完美解决它，继续强势进化： 12345678public class User : ModelBase&#123; public uint UserId &#123; get =&gt; this.GetPropertyValue(() =&gt; this.UserId); set =&gt; this.SetPropertyValue(() =&gt; this.UserId, value); &#125;&#125; 哇喔，有点小崇拜自己了，这代码漂亮的一批！至此，实体基类的API接口基本确定，已经迫不及待想要去实现它了。 提示：由于采用 CallerMemberNameAttribute 自定义标记的参数会导致 C# 编译器要求该参数必需有默认值，因此有些 SetPropertyValue(...) 方法重载版本中 propertyName 参数需要位于参数集的最后，为了与上面的范例代码对应就省略了这些参数的标记，并保持与原有范例相同的签名设计。 1234567891011121314using System;using System.Linq.Expressions;public class ModelBase : INotifyPropertyChanged&#123; public event PropertyChangedEventHandler PropertyChanged; protected object GetPropertyValue([CallerMemberName]string propertyName = null); protected T GetPropertyValue&lt;T&gt;(Expression&lt;Func&lt;T&gt;&gt; property); protected void SetPropertyValue&lt;T&gt;(string propertyName, ref T field, T value); protected void SetPropertyValue&lt;T&gt;(string propertyName, T value); protected void SetPropertyValue&lt;T&gt;(Expression&lt;Func&lt;T&gt;&gt; property, T value);&#125; 实体基类的实现主要思路就是采用字典来记录各属性的变更值，有了这个基础，要继续增加诸如“获取哪些属性发生过变更”之类的需求自然就很容易了： 1234567public class ModelBase : INotifyPropertyChanged&#123; // other members public bool HasChanges(params string[] propertyNames); public IDictionary&lt;string, object&gt; GetChangedPropertys();&#125; 具体的代码就不在这里贴出了，有兴趣的可以参考：https://github.com/Zongsoft/Zongsoft.CoreLibrary/blob/master/src/Common/ModelBase.cs，从功能角度上看，目前的设计还是不错的。但是，某些方法的设计有严重性能缺陷的，主要有以下几点： 每次读写属性都会解析 Lambda 表达式的操作会产生巨大的性能损耗； 采用字典来保存实体属性值的设计机制，会导致值类型的属性读写反复被装箱(Boxing)、拆箱(Unboxing)； 字典的读写效率也远低于直接操作成员字段的语言原语方式。 综上所述，虽然目前方案有性能缺陷，但应对一般场景其实是没有问题的，而且功能和易用性方面都是很好的；但是，性能对于后台程序猿而言犹如悬在头顶的达摩克利斯之剑，这正是这个系列文章要最终解决的问题。在此之前，如果大家有关于这个问题的性能优化方案，欢迎关注我们的公众号（Zongsoft）留言讨论。 敬请期待更精彩的下篇，关注我们的公众号可以第一时间看到哦！","categories":[{"name":"zongsoft","slug":"zongsoft","permalink":"http://zongsoft.com/categories/zongsoft/"}],"tags":[{"name":"entity","slug":"entity","permalink":"http://zongsoft.com/tags/entity/"},{"name":"emit","slug":"emit","permalink":"http://zongsoft.com/tags/emit/"},{"name":"dynamic","slug":"dynamic","permalink":"http://zongsoft.com/tags/dynamic/"},{"name":"generate","slug":"generate","permalink":"http://zongsoft.com/tags/generate/"},{"name":"compile","slug":"compile","permalink":"http://zongsoft.com/tags/compile/"},{"name":"实体","slug":"实体","permalink":"http://zongsoft.com/tags/%E5%AE%9E%E4%BD%93/"},{"name":"动态编译","slug":"动态编译","permalink":"http://zongsoft.com/tags/%E5%8A%A8%E6%80%81%E7%BC%96%E8%AF%91/"},{"name":"动态生成","slug":"动态生成","permalink":"http://zongsoft.com/tags/%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90/"}]},{"title":"搭建 github.io 博客站点","slug":"github-site","date":"2018-07-10T10:00:00.000Z","updated":"2019-11-17T17:45:00.626Z","comments":true,"path":"zh-cn/misc/github-site/","link":"","permalink":"http://zongsoft.com/zh-cn/misc/github-site/","excerpt":"","text":"前言很多人都有搭建博客或知识库站点的想法，可自己买云服务器太不划算，部署管理也是个问题；基于免费又热门的 GitHub Pages 来搭建博客站点倒是省钱省力省事的好办法，于是上网一搜，满屏都是关于使用 Jekyll 来搭建站点的文章，这个 Jekyll 是基于 Ruby 开发的，上手得先装一大坨东西、各种啰嗦各种坑，看的一点欲望都没有了。 神器出现平地一声雷，炸出了 Hexo (https://hexo.io/zh-cn) 这个神器。它只需要 NodeJS 即可，完全不依赖其他乱七八糟的玩意，安装部署超级简单，功能完善、漂亮主题也很多，妥妥的就是它了。 __Hexo __官网：https://hexo.io/zh-cn/ 安装简单，并且官网上提供了很多主题可供选择。 我喜欢的一款主题 (Archer) http://firework.studio/archer-demo/https://github.com/fi3ework/hexo-theme-archer 建站步骤有关一般建站步骤，请参考本文后面的“参考文章”部分，在进行后续操作之前，请按照 Hexo 官网的安装指引，确保 NodeJS 和 Hexo 已经成功安装。 友情提示：在此之前请务必详读 Hexo 官网中的文档。 我们的站点源码：https://github.com/Zongsoft/zongsoft.github.io，没必要把 Hexo 运行环境和使用的主题文件都保存在站点仓库中，所以需要将这些不需要的目录和文件加入到 .gitignore 文件中；站点的 Hexo 基本配置(hexo.config.yml)和相应主题配置文件(hexo.config-theme.archer)需要保留，以便下次或别人构建时将其覆盖还原为默认配置。 站点构建在首次 clone 获取我们站点源码后，按顺序执行下列命令，注意：推荐在 Git Bash 中进行操作。 初始化 Hexo 站点目录： 1hexo init site &amp;&amp; cd site 安装相关插件： 1npm i hexo-generator-json-content --save &amp;&amp; npm i hexo-wordcount --save 获取 Archer 主题： 1git clone https://github.com/fi3ework/hexo-theme-archer.git themes/archer 覆盖 Hexo 默认配置文件： 1cp ../hexo.config.yml _config.yml 覆盖 Archer 主题默认配置文件： 1cp ../hexo.config-theme.archer.yml themes/archer/_config.yml 加入定制的页面布局： 1cp ../post-footer.ejs themes/archer/layout/_partial/post-footer.ejs 安装 Hexo 站点： 1npm install 文章写作上面的构建过程稍微需要花点时间，但只要构建一次之后就不用管它了。 通过 hexo new [layout] &lt;title&gt; 命令来创建一个文章，也可以手动把写好的文章拷贝到源目录(/docs/_posts/)中。 执行 hexo generate 命令生成静态页面(/blog)，生成之后，可以使用 hexo server 命令来查看实际效果。 最后，执行相关 Git 命令将这些改动提交到远程仓库中。 注意：创建了一篇新文章后，务必要设置好文章的元信息（即标题、创建时间、所属分类、Tags等），具体定义请参考 Hexo 官网的这篇文章：https://hexo.io/zh-cn/docs/front-matter.html 提示：如果生成有问题，可以执行 hexo clean 命令来清空输出目录，之后再把项目所需的资源文件手动拷贝到输出目录的相应子目录中。 其他备注 修改 post.ejs (site/themes/archer/layout/) 模板，增加对 post-footer.ejs 局部模板的引用： 123456&lt;main class=\"main post-page\"&gt; &lt;article class=\"article-entry\"&gt; &lt;%- page.content %&gt; &lt;/article&gt;&lt;%- partial('_partial/post-footer') %&gt; 修改 post.ejs 模板中的分页指示的标签： &lt;div class=&quot;nextSlogan&quot;&gt;Next Post&lt;/div&gt;&lt;a class=&quot;nextSlogan&quot; href=&quot;&lt;%- url_for(page.prev.path) %&gt;&quot;&gt;Next Post&lt;/a&gt;… …&lt;div class=&quot;prevSlogan&quot;&gt;Previous Post&lt;/div&gt;&lt;a class=&quot;prevSlogan&quot; href=&quot;&lt;%- url_for(page.next.path) %&gt;&quot;&gt;Previous Post&lt;/a&gt; 调整了 Archer 主题的 _post_page.scss (site/themes/archer/src/scss/_partial/) 中的部分样式： 12345678910111213141516171819// ========== paginator ========== //.post-paginator &#123; li &#123; max-width:18rem; &#125; .nextTitle, .prevTitle&#123; font-size:1.2rem; //remove this line &#125;&#125;// ========== content ========== //.abstract-content,.article-entry &#123; &gt; p &#123; text-indent:2em; &#125;&#125; 参考文章 《使用 Hexo &amp; GitPage 搭建博客》https://yuque.com/skyrin/coding/tm8yf5 《从多说到跟帖：推荐网易云跟帖》https://blog.vadxq.com/dstogentie/ 《集成gitment或者gitalk评论系统》http://www.huyanbing.me/2017/10/20/46383.html","categories":[{"name":"misc","slug":"misc","permalink":"http://zongsoft.com/categories/misc/"}],"tags":[{"name":"github.io","slug":"github-io","permalink":"http://zongsoft.com/tags/github-io/"},{"name":"github pages","slug":"github-pages","permalink":"http://zongsoft.com/tags/github-pages/"},{"name":"Hexo","slug":"Hexo","permalink":"http://zongsoft.com/tags/Hexo/"},{"name":"建站","slug":"建站","permalink":"http://zongsoft.com/tags/%E5%BB%BA%E7%AB%99/"},{"name":"博客","slug":"博客","permalink":"http://zongsoft.com/tags/%E5%8D%9A%E5%AE%A2/"}]}]}